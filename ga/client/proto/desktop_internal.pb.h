// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: desktop_internal.proto

#ifndef PROTOBUF_desktop_5finternal_2eproto__INCLUDED
#define PROTOBUF_desktop_5finternal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "desktop.pb.h"
#include "desktop_extensions.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
class AudioPacket;
class AudioPacketDefaultTypeInternal;
extern AudioPacketDefaultTypeInternal _AudioPacket_default_instance_;
class ClientToHost;
class ClientToHostDefaultTypeInternal;
extern ClientToHostDefaultTypeInternal _ClientToHost_default_instance_;
class ClipboardEvent;
class ClipboardEventDefaultTypeInternal;
extern ClipboardEventDefaultTypeInternal _ClipboardEvent_default_instance_;
class CursorShape;
class CursorShapeDefaultTypeInternal;
extern CursorShapeDefaultTypeInternal _CursorShape_default_instance_;
class DesktopConfig;
class DesktopConfigDefaultTypeInternal;
extern DesktopConfigDefaultTypeInternal _DesktopConfig_default_instance_;
class DesktopConfigRequest;
class DesktopConfigRequestDefaultTypeInternal;
extern DesktopConfigRequestDefaultTypeInternal _DesktopConfigRequest_default_instance_;
class DesktopExtension;
class DesktopExtensionDefaultTypeInternal;
extern DesktopExtensionDefaultTypeInternal _DesktopExtension_default_instance_;
class HostToClient;
class HostToClientDefaultTypeInternal;
extern HostToClientDefaultTypeInternal _HostToClient_default_instance_;
class KeyEvent;
class KeyEventDefaultTypeInternal;
extern KeyEventDefaultTypeInternal _KeyEvent_default_instance_;
class MouseEvent;
class MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class PowerControl;
class PowerControlDefaultTypeInternal;
extern PowerControlDefaultTypeInternal _PowerControl_default_instance_;
class PreferredSize;
class PreferredSizeDefaultTypeInternal;
extern PreferredSizeDefaultTypeInternal _PreferredSize_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class Screen;
class ScreenDefaultTypeInternal;
extern ScreenDefaultTypeInternal _Screen_default_instance_;
class ScreenList;
class ScreenListDefaultTypeInternal;
extern ScreenListDefaultTypeInternal _ScreenList_default_instance_;
class Size;
class SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class SystemInfo;
class SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
class VideoPacket;
class VideoPacketDefaultTypeInternal;
extern VideoPacketDefaultTypeInternal _VideoPacket_default_instance_;
class VideoPacketFormat;
class VideoPacketFormatDefaultTypeInternal;
extern VideoPacketFormatDefaultTypeInternal _VideoPacketFormat_default_instance_;
namespace internal {
class Configure;
class ConfigureDefaultTypeInternal;
extern ConfigureDefaultTypeInternal _Configure_default_instance_;
class Control;
class ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class DesktopFrame;
class DesktopFrameDefaultTypeInternal;
extern DesktopFrameDefaultTypeInternal _DesktopFrame_default_instance_;
class DesktopToService;
class DesktopToServiceDefaultTypeInternal;
extern DesktopToServiceDefaultTypeInternal _DesktopToService_default_instance_;
class MouseCursor;
class MouseCursorDefaultTypeInternal;
extern MouseCursorDefaultTypeInternal _MouseCursor_default_instance_;
class NextScreenCapture;
class NextScreenCaptureDefaultTypeInternal;
extern NextScreenCaptureDefaultTypeInternal _NextScreenCapture_default_instance_;
class ScreenCaptured;
class ScreenCapturedDefaultTypeInternal;
extern ScreenCapturedDefaultTypeInternal _ScreenCaptured_default_instance_;
class SelectSource;
class SelectSourceDefaultTypeInternal;
extern SelectSourceDefaultTypeInternal _SelectSource_default_instance_;
class ServiceToDesktop;
class ServiceToDesktopDefaultTypeInternal;
extern ServiceToDesktopDefaultTypeInternal _ServiceToDesktop_default_instance_;
class SharedBuffer;
class SharedBufferDefaultTypeInternal;
extern SharedBufferDefaultTypeInternal _SharedBuffer_default_instance_;
}  // namespace internal
}  // namespace proto

namespace proto {
namespace internal {

namespace protobuf_desktop_5finternal_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_desktop_5finternal_2eproto

enum SharedBuffer_Type {
  SharedBuffer_Type_CREATE = 0,
  SharedBuffer_Type_RELEASE = 1,
  SharedBuffer_Type_SharedBuffer_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SharedBuffer_Type_SharedBuffer_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SharedBuffer_Type_IsValid(int value);
const SharedBuffer_Type SharedBuffer_Type_Type_MIN = SharedBuffer_Type_CREATE;
const SharedBuffer_Type SharedBuffer_Type_Type_MAX = SharedBuffer_Type_RELEASE;
const int SharedBuffer_Type_Type_ARRAYSIZE = SharedBuffer_Type_Type_MAX + 1;

enum Control_Action {
  Control_Action_UNKNOWN = 0,
  Control_Action_DISABLE = 1,
  Control_Action_ENABLE = 2,
  Control_Action_LOGOFF = 3,
  Control_Action_LOCK = 4,
  Control_Action_Control_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_Action_Control_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_Action_IsValid(int value);
const Control_Action Control_Action_Action_MIN = Control_Action_UNKNOWN;
const Control_Action Control_Action_Action_MAX = Control_Action_LOCK;
const int Control_Action_Action_ARRAYSIZE = Control_Action_Action_MAX + 1;

// ===================================================================

class DesktopFrame : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.DesktopFrame) */ {
 public:
  DesktopFrame();
  virtual ~DesktopFrame();

  DesktopFrame(const DesktopFrame& from);

  inline DesktopFrame& operator=(const DesktopFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const DesktopFrame& default_instance();

  static inline const DesktopFrame* internal_default_instance() {
    return reinterpret_cast<const DesktopFrame*>(
               &_DesktopFrame_default_instance_);
  }

  void Swap(DesktopFrame* other);

  // implements Message ----------------------------------------------

  inline DesktopFrame* New() const PROTOBUF_FINAL { return New(NULL); }

  DesktopFrame* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesktopFrame& from);
  void MergeFrom(const DesktopFrame& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopFrame* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Rect dirty_rect = 7;
  int dirty_rect_size() const;
  void clear_dirty_rect();
  static const int kDirtyRectFieldNumber = 7;
  const ::proto::Rect& dirty_rect(int index) const;
  ::proto::Rect* mutable_dirty_rect(int index);
  ::proto::Rect* add_dirty_rect();
  ::google::protobuf::RepeatedPtrField< ::proto::Rect >*
      mutable_dirty_rect();
  const ::google::protobuf::RepeatedPtrField< ::proto::Rect >&
      dirty_rect() const;

  // uint32 capturer_type = 1;
  void clear_capturer_type();
  static const int kCapturerTypeFieldNumber = 1;
  ::google::protobuf::uint32 capturer_type() const;
  void set_capturer_type(::google::protobuf::uint32 value);

  // int32 shared_buffer_id = 2;
  void clear_shared_buffer_id();
  static const int kSharedBufferIdFieldNumber = 2;
  ::google::protobuf::int32 shared_buffer_id() const;
  void set_shared_buffer_id(::google::protobuf::int32 value);

  // int32 width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 dpi_x = 5;
  void clear_dpi_x();
  static const int kDpiXFieldNumber = 5;
  ::google::protobuf::int32 dpi_x() const;
  void set_dpi_x(::google::protobuf::int32 value);

  // int32 dpi_y = 6;
  void clear_dpi_y();
  static const int kDpiYFieldNumber = 6;
  ::google::protobuf::int32 dpi_y() const;
  void set_dpi_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.internal.DesktopFrame)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Rect > dirty_rect_;
  ::google::protobuf::uint32 capturer_type_;
  ::google::protobuf::int32 shared_buffer_id_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 dpi_x_;
  ::google::protobuf::int32 dpi_y_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MouseCursor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.MouseCursor) */ {
 public:
  MouseCursor();
  virtual ~MouseCursor();

  MouseCursor(const MouseCursor& from);

  inline MouseCursor& operator=(const MouseCursor& from) {
    CopyFrom(from);
    return *this;
  }

  static const MouseCursor& default_instance();

  static inline const MouseCursor* internal_default_instance() {
    return reinterpret_cast<const MouseCursor*>(
               &_MouseCursor_default_instance_);
  }

  void Swap(MouseCursor* other);

  // implements Message ----------------------------------------------

  inline MouseCursor* New() const PROTOBUF_FINAL { return New(NULL); }

  MouseCursor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MouseCursor& from);
  void MergeFrom(const MouseCursor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MouseCursor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 5;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // int32 hotspot_x = 3;
  void clear_hotspot_x();
  static const int kHotspotXFieldNumber = 3;
  ::google::protobuf::int32 hotspot_x() const;
  void set_hotspot_x(::google::protobuf::int32 value);

  // int32 hotspot_y = 4;
  void clear_hotspot_y();
  static const int kHotspotYFieldNumber = 4;
  ::google::protobuf::int32 hotspot_y() const;
  void set_hotspot_y(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.internal.MouseCursor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int32 hotspot_x_;
  ::google::protobuf::int32 hotspot_y_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SharedBuffer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.SharedBuffer) */ {
 public:
  SharedBuffer();
  virtual ~SharedBuffer();

  SharedBuffer(const SharedBuffer& from);

  inline SharedBuffer& operator=(const SharedBuffer& from) {
    CopyFrom(from);
    return *this;
  }

  static const SharedBuffer& default_instance();

  static inline const SharedBuffer* internal_default_instance() {
    return reinterpret_cast<const SharedBuffer*>(
               &_SharedBuffer_default_instance_);
  }

  void Swap(SharedBuffer* other);

  // implements Message ----------------------------------------------

  inline SharedBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  SharedBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SharedBuffer& from);
  void MergeFrom(const SharedBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SharedBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SharedBuffer_Type Type;
  static const Type CREATE =
    SharedBuffer_Type_CREATE;
  static const Type RELEASE =
    SharedBuffer_Type_RELEASE;
  static inline bool Type_IsValid(int value) {
    return SharedBuffer_Type_IsValid(value);
  }
  static const Type Type_MIN =
    SharedBuffer_Type_Type_MIN;
  static const Type Type_MAX =
    SharedBuffer_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    SharedBuffer_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.internal.SharedBuffer.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::internal::SharedBuffer_Type type() const;
  void set_type(::proto::internal::SharedBuffer_Type value);

  // int32 shared_buffer_id = 2;
  void clear_shared_buffer_id();
  static const int kSharedBufferIdFieldNumber = 2;
  ::google::protobuf::int32 shared_buffer_id() const;
  void set_shared_buffer_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.internal.SharedBuffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int type_;
  ::google::protobuf::int32 shared_buffer_id_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScreenCaptured : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.ScreenCaptured) */ {
 public:
  ScreenCaptured();
  virtual ~ScreenCaptured();

  ScreenCaptured(const ScreenCaptured& from);

  inline ScreenCaptured& operator=(const ScreenCaptured& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScreenCaptured& default_instance();

  static inline const ScreenCaptured* internal_default_instance() {
    return reinterpret_cast<const ScreenCaptured*>(
               &_ScreenCaptured_default_instance_);
  }

  void Swap(ScreenCaptured* other);

  // implements Message ----------------------------------------------

  inline ScreenCaptured* New() const PROTOBUF_FINAL { return New(NULL); }

  ScreenCaptured* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ScreenCaptured& from);
  void MergeFrom(const ScreenCaptured& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScreenCaptured* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.internal.DesktopFrame frame = 1;
  bool has_frame() const;
  void clear_frame();
  static const int kFrameFieldNumber = 1;
  const ::proto::internal::DesktopFrame& frame() const;
  ::proto::internal::DesktopFrame* mutable_frame();
  ::proto::internal::DesktopFrame* release_frame();
  void set_allocated_frame(::proto::internal::DesktopFrame* frame);

  // .proto.internal.MouseCursor mouse_cursor = 2;
  bool has_mouse_cursor() const;
  void clear_mouse_cursor();
  static const int kMouseCursorFieldNumber = 2;
  const ::proto::internal::MouseCursor& mouse_cursor() const;
  ::proto::internal::MouseCursor* mutable_mouse_cursor();
  ::proto::internal::MouseCursor* release_mouse_cursor();
  void set_allocated_mouse_cursor(::proto::internal::MouseCursor* mouse_cursor);

  // @@protoc_insertion_point(class_scope:proto.internal.ScreenCaptured)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::internal::DesktopFrame* frame_;
  ::proto::internal::MouseCursor* mouse_cursor_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NextScreenCapture : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.NextScreenCapture) */ {
 public:
  NextScreenCapture();
  virtual ~NextScreenCapture();

  NextScreenCapture(const NextScreenCapture& from);

  inline NextScreenCapture& operator=(const NextScreenCapture& from) {
    CopyFrom(from);
    return *this;
  }

  static const NextScreenCapture& default_instance();

  static inline const NextScreenCapture* internal_default_instance() {
    return reinterpret_cast<const NextScreenCapture*>(
               &_NextScreenCapture_default_instance_);
  }

  void Swap(NextScreenCapture* other);

  // implements Message ----------------------------------------------

  inline NextScreenCapture* New() const PROTOBUF_FINAL { return New(NULL); }

  NextScreenCapture* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NextScreenCapture& from);
  void MergeFrom(const NextScreenCapture& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NextScreenCapture* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 update_interval = 1;
  void clear_update_interval();
  static const int kUpdateIntervalFieldNumber = 1;
  ::google::protobuf::uint32 update_interval() const;
  void set_update_interval(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.internal.NextScreenCapture)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 update_interval_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SelectSource : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.SelectSource) */ {
 public:
  SelectSource();
  virtual ~SelectSource();

  SelectSource(const SelectSource& from);

  inline SelectSource& operator=(const SelectSource& from) {
    CopyFrom(from);
    return *this;
  }

  static const SelectSource& default_instance();

  static inline const SelectSource* internal_default_instance() {
    return reinterpret_cast<const SelectSource*>(
               &_SelectSource_default_instance_);
  }

  void Swap(SelectSource* other);

  // implements Message ----------------------------------------------

  inline SelectSource* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectSource* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SelectSource& from);
  void MergeFrom(const SelectSource& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectSource* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.Screen screen = 1;
  bool has_screen() const;
  void clear_screen();
  static const int kScreenFieldNumber = 1;
  const ::proto::Screen& screen() const;
  ::proto::Screen* mutable_screen();
  ::proto::Screen* release_screen();
  void set_allocated_screen(::proto::Screen* screen);

  // @@protoc_insertion_point(class_scope:proto.internal.SelectSource)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::Screen* screen_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Configure : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.Configure) */ {
 public:
  Configure();
  virtual ~Configure();

  Configure(const Configure& from);

  inline Configure& operator=(const Configure& from) {
    CopyFrom(from);
    return *this;
  }

  static const Configure& default_instance();

  static inline const Configure* internal_default_instance() {
    return reinterpret_cast<const Configure*>(
               &_Configure_default_instance_);
  }

  void Swap(Configure* other);

  // implements Message ----------------------------------------------

  inline Configure* New() const PROTOBUF_FINAL { return New(NULL); }

  Configure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Configure& from);
  void MergeFrom(const Configure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Configure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool disable_font_smoothing = 1;
  void clear_disable_font_smoothing();
  static const int kDisableFontSmoothingFieldNumber = 1;
  bool disable_font_smoothing() const;
  void set_disable_font_smoothing(bool value);

  // bool disable_wallpaper = 2;
  void clear_disable_wallpaper();
  static const int kDisableWallpaperFieldNumber = 2;
  bool disable_wallpaper() const;
  void set_disable_wallpaper(bool value);

  // bool disable_effects = 3;
  void clear_disable_effects();
  static const int kDisableEffectsFieldNumber = 3;
  bool disable_effects() const;
  void set_disable_effects(bool value);

  // bool block_input = 4;
  void clear_block_input();
  static const int kBlockInputFieldNumber = 4;
  bool block_input() const;
  void set_block_input(bool value);

  // bool lock_at_disconnect = 5;
  void clear_lock_at_disconnect();
  static const int kLockAtDisconnectFieldNumber = 5;
  bool lock_at_disconnect() const;
  void set_lock_at_disconnect(bool value);

  // @@protoc_insertion_point(class_scope:proto.internal.Configure)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  bool disable_font_smoothing_;
  bool disable_wallpaper_;
  bool disable_effects_;
  bool block_input_;
  bool lock_at_disconnect_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.Control) */ {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }

  static const Control& default_instance();

  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }

  void Swap(Control* other);

  // implements Message ----------------------------------------------

  inline Control* New() const PROTOBUF_FINAL { return New(NULL); }

  Control* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Control_Action Action;
  static const Action UNKNOWN =
    Control_Action_UNKNOWN;
  static const Action DISABLE =
    Control_Action_DISABLE;
  static const Action ENABLE =
    Control_Action_ENABLE;
  static const Action LOGOFF =
    Control_Action_LOGOFF;
  static const Action LOCK =
    Control_Action_LOCK;
  static inline bool Action_IsValid(int value) {
    return Control_Action_IsValid(value);
  }
  static const Action Action_MIN =
    Control_Action_Action_MIN;
  static const Action Action_MAX =
    Control_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    Control_Action_Action_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.internal.Control.Action action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::proto::internal::Control_Action action() const;
  void set_action(::proto::internal::Control_Action value);

  // @@protoc_insertion_point(class_scope:proto.internal.Control)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int action_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServiceToDesktop : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.ServiceToDesktop) */ {
 public:
  ServiceToDesktop();
  virtual ~ServiceToDesktop();

  ServiceToDesktop(const ServiceToDesktop& from);

  inline ServiceToDesktop& operator=(const ServiceToDesktop& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServiceToDesktop& default_instance();

  static inline const ServiceToDesktop* internal_default_instance() {
    return reinterpret_cast<const ServiceToDesktop*>(
               &_ServiceToDesktop_default_instance_);
  }

  void Swap(ServiceToDesktop* other);

  // implements Message ----------------------------------------------

  inline ServiceToDesktop* New() const PROTOBUF_FINAL { return New(NULL); }

  ServiceToDesktop* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ServiceToDesktop& from);
  void MergeFrom(const ServiceToDesktop& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServiceToDesktop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.internal.Control control = 1;
  bool has_control() const;
  void clear_control();
  static const int kControlFieldNumber = 1;
  const ::proto::internal::Control& control() const;
  ::proto::internal::Control* mutable_control();
  ::proto::internal::Control* release_control();
  void set_allocated_control(::proto::internal::Control* control);

  // .proto.internal.Configure configure = 2;
  bool has_configure() const;
  void clear_configure();
  static const int kConfigureFieldNumber = 2;
  const ::proto::internal::Configure& configure() const;
  ::proto::internal::Configure* mutable_configure();
  ::proto::internal::Configure* release_configure();
  void set_allocated_configure(::proto::internal::Configure* configure);

  // .proto.internal.SelectSource select_source = 3;
  bool has_select_source() const;
  void clear_select_source();
  static const int kSelectSourceFieldNumber = 3;
  const ::proto::internal::SelectSource& select_source() const;
  ::proto::internal::SelectSource* mutable_select_source();
  ::proto::internal::SelectSource* release_select_source();
  void set_allocated_select_source(::proto::internal::SelectSource* select_source);

  // .proto.internal.NextScreenCapture next_screen_capture = 4;
  bool has_next_screen_capture() const;
  void clear_next_screen_capture();
  static const int kNextScreenCaptureFieldNumber = 4;
  const ::proto::internal::NextScreenCapture& next_screen_capture() const;
  ::proto::internal::NextScreenCapture* mutable_next_screen_capture();
  ::proto::internal::NextScreenCapture* release_next_screen_capture();
  void set_allocated_next_screen_capture(::proto::internal::NextScreenCapture* next_screen_capture);

  // .proto.KeyEvent key_event = 5;
  bool has_key_event() const;
  void clear_key_event();
  static const int kKeyEventFieldNumber = 5;
  const ::proto::KeyEvent& key_event() const;
  ::proto::KeyEvent* mutable_key_event();
  ::proto::KeyEvent* release_key_event();
  void set_allocated_key_event(::proto::KeyEvent* key_event);

  // .proto.MouseEvent mouse_event = 6;
  bool has_mouse_event() const;
  void clear_mouse_event();
  static const int kMouseEventFieldNumber = 6;
  const ::proto::MouseEvent& mouse_event() const;
  ::proto::MouseEvent* mutable_mouse_event();
  ::proto::MouseEvent* release_mouse_event();
  void set_allocated_mouse_event(::proto::MouseEvent* mouse_event);

  // .proto.ClipboardEvent clipboard_event = 7;
  bool has_clipboard_event() const;
  void clear_clipboard_event();
  static const int kClipboardEventFieldNumber = 7;
  const ::proto::ClipboardEvent& clipboard_event() const;
  ::proto::ClipboardEvent* mutable_clipboard_event();
  ::proto::ClipboardEvent* release_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);

  // @@protoc_insertion_point(class_scope:proto.internal.ServiceToDesktop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::internal::Control* control_;
  ::proto::internal::Configure* configure_;
  ::proto::internal::SelectSource* select_source_;
  ::proto::internal::NextScreenCapture* next_screen_capture_;
  ::proto::KeyEvent* key_event_;
  ::proto::MouseEvent* mouse_event_;
  ::proto::ClipboardEvent* clipboard_event_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DesktopToService : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.internal.DesktopToService) */ {
 public:
  DesktopToService();
  virtual ~DesktopToService();

  DesktopToService(const DesktopToService& from);

  inline DesktopToService& operator=(const DesktopToService& from) {
    CopyFrom(from);
    return *this;
  }

  static const DesktopToService& default_instance();

  static inline const DesktopToService* internal_default_instance() {
    return reinterpret_cast<const DesktopToService*>(
               &_DesktopToService_default_instance_);
  }

  void Swap(DesktopToService* other);

  // implements Message ----------------------------------------------

  inline DesktopToService* New() const PROTOBUF_FINAL { return New(NULL); }

  DesktopToService* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DesktopToService& from);
  void MergeFrom(const DesktopToService& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DesktopToService* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.ScreenList screen_list = 1;
  bool has_screen_list() const;
  void clear_screen_list();
  static const int kScreenListFieldNumber = 1;
  const ::proto::ScreenList& screen_list() const;
  ::proto::ScreenList* mutable_screen_list();
  ::proto::ScreenList* release_screen_list();
  void set_allocated_screen_list(::proto::ScreenList* screen_list);

  // .proto.internal.SharedBuffer shared_buffer = 2;
  bool has_shared_buffer() const;
  void clear_shared_buffer();
  static const int kSharedBufferFieldNumber = 2;
  const ::proto::internal::SharedBuffer& shared_buffer() const;
  ::proto::internal::SharedBuffer* mutable_shared_buffer();
  ::proto::internal::SharedBuffer* release_shared_buffer();
  void set_allocated_shared_buffer(::proto::internal::SharedBuffer* shared_buffer);

  // .proto.internal.ScreenCaptured screen_captured = 3;
  bool has_screen_captured() const;
  void clear_screen_captured();
  static const int kScreenCapturedFieldNumber = 3;
  const ::proto::internal::ScreenCaptured& screen_captured() const;
  ::proto::internal::ScreenCaptured* mutable_screen_captured();
  ::proto::internal::ScreenCaptured* release_screen_captured();
  void set_allocated_screen_captured(::proto::internal::ScreenCaptured* screen_captured);

  // .proto.AudioPacket audio_packet = 4;
  bool has_audio_packet() const;
  void clear_audio_packet();
  static const int kAudioPacketFieldNumber = 4;
  const ::proto::AudioPacket& audio_packet() const;
  ::proto::AudioPacket* mutable_audio_packet();
  ::proto::AudioPacket* release_audio_packet();
  void set_allocated_audio_packet(::proto::AudioPacket* audio_packet);

  // .proto.ClipboardEvent clipboard_event = 5;
  bool has_clipboard_event() const;
  void clear_clipboard_event();
  static const int kClipboardEventFieldNumber = 5;
  const ::proto::ClipboardEvent& clipboard_event() const;
  ::proto::ClipboardEvent* mutable_clipboard_event();
  ::proto::ClipboardEvent* release_clipboard_event();
  void set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event);

  // @@protoc_insertion_point(class_scope:proto.internal.DesktopToService)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::ScreenList* screen_list_;
  ::proto::internal::SharedBuffer* shared_buffer_;
  ::proto::internal::ScreenCaptured* screen_captured_;
  ::proto::AudioPacket* audio_packet_;
  ::proto::ClipboardEvent* clipboard_event_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5finternal_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// DesktopFrame

// uint32 capturer_type = 1;
inline void DesktopFrame::clear_capturer_type() {
  capturer_type_ = 0u;
}
inline ::google::protobuf::uint32 DesktopFrame::capturer_type() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.capturer_type)
  return capturer_type_;
}
inline void DesktopFrame::set_capturer_type(::google::protobuf::uint32 value) {
  
  capturer_type_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.capturer_type)
}

// int32 shared_buffer_id = 2;
inline void DesktopFrame::clear_shared_buffer_id() {
  shared_buffer_id_ = 0;
}
inline ::google::protobuf::int32 DesktopFrame::shared_buffer_id() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.shared_buffer_id)
  return shared_buffer_id_;
}
inline void DesktopFrame::set_shared_buffer_id(::google::protobuf::int32 value) {
  
  shared_buffer_id_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.shared_buffer_id)
}

// int32 width = 3;
inline void DesktopFrame::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 DesktopFrame::width() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.width)
  return width_;
}
inline void DesktopFrame::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.width)
}

// int32 height = 4;
inline void DesktopFrame::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 DesktopFrame::height() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.height)
  return height_;
}
inline void DesktopFrame::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.height)
}

// int32 dpi_x = 5;
inline void DesktopFrame::clear_dpi_x() {
  dpi_x_ = 0;
}
inline ::google::protobuf::int32 DesktopFrame::dpi_x() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.dpi_x)
  return dpi_x_;
}
inline void DesktopFrame::set_dpi_x(::google::protobuf::int32 value) {
  
  dpi_x_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.dpi_x)
}

// int32 dpi_y = 6;
inline void DesktopFrame::clear_dpi_y() {
  dpi_y_ = 0;
}
inline ::google::protobuf::int32 DesktopFrame::dpi_y() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.dpi_y)
  return dpi_y_;
}
inline void DesktopFrame::set_dpi_y(::google::protobuf::int32 value) {
  
  dpi_y_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.DesktopFrame.dpi_y)
}

// repeated .proto.Rect dirty_rect = 7;
inline int DesktopFrame::dirty_rect_size() const {
  return dirty_rect_.size();
}
inline void DesktopFrame::clear_dirty_rect() {
  dirty_rect_.Clear();
}
inline const ::proto::Rect& DesktopFrame::dirty_rect(int index) const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopFrame.dirty_rect)
  return dirty_rect_.Get(index);
}
inline ::proto::Rect* DesktopFrame::mutable_dirty_rect(int index) {
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopFrame.dirty_rect)
  return dirty_rect_.Mutable(index);
}
inline ::proto::Rect* DesktopFrame::add_dirty_rect() {
  // @@protoc_insertion_point(field_add:proto.internal.DesktopFrame.dirty_rect)
  return dirty_rect_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Rect >*
DesktopFrame::mutable_dirty_rect() {
  // @@protoc_insertion_point(field_mutable_list:proto.internal.DesktopFrame.dirty_rect)
  return &dirty_rect_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Rect >&
DesktopFrame::dirty_rect() const {
  // @@protoc_insertion_point(field_list:proto.internal.DesktopFrame.dirty_rect)
  return dirty_rect_;
}

// -------------------------------------------------------------------

// MouseCursor

// int32 width = 1;
inline void MouseCursor::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 MouseCursor::width() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.width)
  return width_;
}
inline void MouseCursor::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.width)
}

// int32 height = 2;
inline void MouseCursor::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 MouseCursor::height() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.height)
  return height_;
}
inline void MouseCursor::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.height)
}

// int32 hotspot_x = 3;
inline void MouseCursor::clear_hotspot_x() {
  hotspot_x_ = 0;
}
inline ::google::protobuf::int32 MouseCursor::hotspot_x() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.hotspot_x)
  return hotspot_x_;
}
inline void MouseCursor::set_hotspot_x(::google::protobuf::int32 value) {
  
  hotspot_x_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.hotspot_x)
}

// int32 hotspot_y = 4;
inline void MouseCursor::clear_hotspot_y() {
  hotspot_y_ = 0;
}
inline ::google::protobuf::int32 MouseCursor::hotspot_y() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.hotspot_y)
  return hotspot_y_;
}
inline void MouseCursor::set_hotspot_y(::google::protobuf::int32 value) {
  
  hotspot_y_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.hotspot_y)
}

// bytes data = 5;
inline void MouseCursor::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MouseCursor::data() const {
  // @@protoc_insertion_point(field_get:proto.internal.MouseCursor.data)
  return data_.GetNoArena();
}
inline void MouseCursor::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.internal.MouseCursor.data)
}
#if LANG_CXX11
inline void MouseCursor::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.internal.MouseCursor.data)
}
#endif
inline void MouseCursor::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.internal.MouseCursor.data)
}
inline void MouseCursor::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.internal.MouseCursor.data)
}
inline ::std::string* MouseCursor::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:proto.internal.MouseCursor.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MouseCursor::release_data() {
  // @@protoc_insertion_point(field_release:proto.internal.MouseCursor.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MouseCursor::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:proto.internal.MouseCursor.data)
}

// -------------------------------------------------------------------

// SharedBuffer

// .proto.internal.SharedBuffer.Type type = 1;
inline void SharedBuffer::clear_type() {
  type_ = 0;
}
inline ::proto::internal::SharedBuffer_Type SharedBuffer::type() const {
  // @@protoc_insertion_point(field_get:proto.internal.SharedBuffer.type)
  return static_cast< ::proto::internal::SharedBuffer_Type >(type_);
}
inline void SharedBuffer::set_type(::proto::internal::SharedBuffer_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.SharedBuffer.type)
}

// int32 shared_buffer_id = 2;
inline void SharedBuffer::clear_shared_buffer_id() {
  shared_buffer_id_ = 0;
}
inline ::google::protobuf::int32 SharedBuffer::shared_buffer_id() const {
  // @@protoc_insertion_point(field_get:proto.internal.SharedBuffer.shared_buffer_id)
  return shared_buffer_id_;
}
inline void SharedBuffer::set_shared_buffer_id(::google::protobuf::int32 value) {
  
  shared_buffer_id_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.SharedBuffer.shared_buffer_id)
}

// -------------------------------------------------------------------

// ScreenCaptured

// .proto.internal.DesktopFrame frame = 1;
inline bool ScreenCaptured::has_frame() const {
  return this != internal_default_instance() && frame_ != NULL;
}
inline void ScreenCaptured::clear_frame() {
  if (GetArenaNoVirtual() == NULL && frame_ != NULL) delete frame_;
  frame_ = NULL;
}
inline const ::proto::internal::DesktopFrame& ScreenCaptured::frame() const {
  // @@protoc_insertion_point(field_get:proto.internal.ScreenCaptured.frame)
  return frame_ != NULL ? *frame_
                         : *::proto::internal::DesktopFrame::internal_default_instance();
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::mutable_frame() {
  
  if (frame_ == NULL) {
    frame_ = new ::proto::internal::DesktopFrame;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ScreenCaptured.frame)
  return frame_;
}
inline ::proto::internal::DesktopFrame* ScreenCaptured::release_frame() {
  // @@protoc_insertion_point(field_release:proto.internal.ScreenCaptured.frame)
  
  ::proto::internal::DesktopFrame* temp = frame_;
  frame_ = NULL;
  return temp;
}
inline void ScreenCaptured::set_allocated_frame(::proto::internal::DesktopFrame* frame) {
  delete frame_;
  frame_ = frame;
  if (frame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ScreenCaptured.frame)
}

// .proto.internal.MouseCursor mouse_cursor = 2;
inline bool ScreenCaptured::has_mouse_cursor() const {
  return this != internal_default_instance() && mouse_cursor_ != NULL;
}
inline void ScreenCaptured::clear_mouse_cursor() {
  if (GetArenaNoVirtual() == NULL && mouse_cursor_ != NULL) delete mouse_cursor_;
  mouse_cursor_ = NULL;
}
inline const ::proto::internal::MouseCursor& ScreenCaptured::mouse_cursor() const {
  // @@protoc_insertion_point(field_get:proto.internal.ScreenCaptured.mouse_cursor)
  return mouse_cursor_ != NULL ? *mouse_cursor_
                         : *::proto::internal::MouseCursor::internal_default_instance();
}
inline ::proto::internal::MouseCursor* ScreenCaptured::mutable_mouse_cursor() {
  
  if (mouse_cursor_ == NULL) {
    mouse_cursor_ = new ::proto::internal::MouseCursor;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ScreenCaptured.mouse_cursor)
  return mouse_cursor_;
}
inline ::proto::internal::MouseCursor* ScreenCaptured::release_mouse_cursor() {
  // @@protoc_insertion_point(field_release:proto.internal.ScreenCaptured.mouse_cursor)
  
  ::proto::internal::MouseCursor* temp = mouse_cursor_;
  mouse_cursor_ = NULL;
  return temp;
}
inline void ScreenCaptured::set_allocated_mouse_cursor(::proto::internal::MouseCursor* mouse_cursor) {
  delete mouse_cursor_;
  mouse_cursor_ = mouse_cursor;
  if (mouse_cursor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ScreenCaptured.mouse_cursor)
}

// -------------------------------------------------------------------

// NextScreenCapture

// uint32 update_interval = 1;
inline void NextScreenCapture::clear_update_interval() {
  update_interval_ = 0u;
}
inline ::google::protobuf::uint32 NextScreenCapture::update_interval() const {
  // @@protoc_insertion_point(field_get:proto.internal.NextScreenCapture.update_interval)
  return update_interval_;
}
inline void NextScreenCapture::set_update_interval(::google::protobuf::uint32 value) {
  
  update_interval_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.NextScreenCapture.update_interval)
}

// -------------------------------------------------------------------

// SelectSource

// .proto.Screen screen = 1;
inline bool SelectSource::has_screen() const {
  return this != internal_default_instance() && screen_ != NULL;
}
inline void SelectSource::clear_screen() {
  if (GetArenaNoVirtual() == NULL && screen_ != NULL) delete screen_;
  screen_ = NULL;
}
inline const ::proto::Screen& SelectSource::screen() const {
  // @@protoc_insertion_point(field_get:proto.internal.SelectSource.screen)
  return screen_ != NULL ? *screen_
                         : *::proto::Screen::internal_default_instance();
}
inline ::proto::Screen* SelectSource::mutable_screen() {
  
  if (screen_ == NULL) {
    screen_ = new ::proto::Screen;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.SelectSource.screen)
  return screen_;
}
inline ::proto::Screen* SelectSource::release_screen() {
  // @@protoc_insertion_point(field_release:proto.internal.SelectSource.screen)
  
  ::proto::Screen* temp = screen_;
  screen_ = NULL;
  return temp;
}
inline void SelectSource::set_allocated_screen(::proto::Screen* screen) {
  delete screen_;
  screen_ = screen;
  if (screen) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.SelectSource.screen)
}

// -------------------------------------------------------------------

// Configure

// bool disable_font_smoothing = 1;
inline void Configure::clear_disable_font_smoothing() {
  disable_font_smoothing_ = false;
}
inline bool Configure::disable_font_smoothing() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_font_smoothing)
  return disable_font_smoothing_;
}
inline void Configure::set_disable_font_smoothing(bool value) {
  
  disable_font_smoothing_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_font_smoothing)
}

// bool disable_wallpaper = 2;
inline void Configure::clear_disable_wallpaper() {
  disable_wallpaper_ = false;
}
inline bool Configure::disable_wallpaper() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_wallpaper)
  return disable_wallpaper_;
}
inline void Configure::set_disable_wallpaper(bool value) {
  
  disable_wallpaper_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_wallpaper)
}

// bool disable_effects = 3;
inline void Configure::clear_disable_effects() {
  disable_effects_ = false;
}
inline bool Configure::disable_effects() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.disable_effects)
  return disable_effects_;
}
inline void Configure::set_disable_effects(bool value) {
  
  disable_effects_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Configure.disable_effects)
}

// bool block_input = 4;
inline void Configure::clear_block_input() {
  block_input_ = false;
}
inline bool Configure::block_input() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.block_input)
  return block_input_;
}
inline void Configure::set_block_input(bool value) {
  
  block_input_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Configure.block_input)
}

// bool lock_at_disconnect = 5;
inline void Configure::clear_lock_at_disconnect() {
  lock_at_disconnect_ = false;
}
inline bool Configure::lock_at_disconnect() const {
  // @@protoc_insertion_point(field_get:proto.internal.Configure.lock_at_disconnect)
  return lock_at_disconnect_;
}
inline void Configure::set_lock_at_disconnect(bool value) {
  
  lock_at_disconnect_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Configure.lock_at_disconnect)
}

// -------------------------------------------------------------------

// Control

// .proto.internal.Control.Action action = 1;
inline void Control::clear_action() {
  action_ = 0;
}
inline ::proto::internal::Control_Action Control::action() const {
  // @@protoc_insertion_point(field_get:proto.internal.Control.action)
  return static_cast< ::proto::internal::Control_Action >(action_);
}
inline void Control::set_action(::proto::internal::Control_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:proto.internal.Control.action)
}

// -------------------------------------------------------------------

// ServiceToDesktop

// .proto.internal.Control control = 1;
inline bool ServiceToDesktop::has_control() const {
  return this != internal_default_instance() && control_ != NULL;
}
inline void ServiceToDesktop::clear_control() {
  if (GetArenaNoVirtual() == NULL && control_ != NULL) delete control_;
  control_ = NULL;
}
inline const ::proto::internal::Control& ServiceToDesktop::control() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.control)
  return control_ != NULL ? *control_
                         : *::proto::internal::Control::internal_default_instance();
}
inline ::proto::internal::Control* ServiceToDesktop::mutable_control() {
  
  if (control_ == NULL) {
    control_ = new ::proto::internal::Control;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.control)
  return control_;
}
inline ::proto::internal::Control* ServiceToDesktop::release_control() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.control)
  
  ::proto::internal::Control* temp = control_;
  control_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_control(::proto::internal::Control* control) {
  delete control_;
  control_ = control;
  if (control) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.control)
}

// .proto.internal.Configure configure = 2;
inline bool ServiceToDesktop::has_configure() const {
  return this != internal_default_instance() && configure_ != NULL;
}
inline void ServiceToDesktop::clear_configure() {
  if (GetArenaNoVirtual() == NULL && configure_ != NULL) delete configure_;
  configure_ = NULL;
}
inline const ::proto::internal::Configure& ServiceToDesktop::configure() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.configure)
  return configure_ != NULL ? *configure_
                         : *::proto::internal::Configure::internal_default_instance();
}
inline ::proto::internal::Configure* ServiceToDesktop::mutable_configure() {
  
  if (configure_ == NULL) {
    configure_ = new ::proto::internal::Configure;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.configure)
  return configure_;
}
inline ::proto::internal::Configure* ServiceToDesktop::release_configure() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.configure)
  
  ::proto::internal::Configure* temp = configure_;
  configure_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_configure(::proto::internal::Configure* configure) {
  delete configure_;
  configure_ = configure;
  if (configure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.configure)
}

// .proto.internal.SelectSource select_source = 3;
inline bool ServiceToDesktop::has_select_source() const {
  return this != internal_default_instance() && select_source_ != NULL;
}
inline void ServiceToDesktop::clear_select_source() {
  if (GetArenaNoVirtual() == NULL && select_source_ != NULL) delete select_source_;
  select_source_ = NULL;
}
inline const ::proto::internal::SelectSource& ServiceToDesktop::select_source() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.select_source)
  return select_source_ != NULL ? *select_source_
                         : *::proto::internal::SelectSource::internal_default_instance();
}
inline ::proto::internal::SelectSource* ServiceToDesktop::mutable_select_source() {
  
  if (select_source_ == NULL) {
    select_source_ = new ::proto::internal::SelectSource;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.select_source)
  return select_source_;
}
inline ::proto::internal::SelectSource* ServiceToDesktop::release_select_source() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.select_source)
  
  ::proto::internal::SelectSource* temp = select_source_;
  select_source_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_select_source(::proto::internal::SelectSource* select_source) {
  delete select_source_;
  select_source_ = select_source;
  if (select_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.select_source)
}

// .proto.internal.NextScreenCapture next_screen_capture = 4;
inline bool ServiceToDesktop::has_next_screen_capture() const {
  return this != internal_default_instance() && next_screen_capture_ != NULL;
}
inline void ServiceToDesktop::clear_next_screen_capture() {
  if (GetArenaNoVirtual() == NULL && next_screen_capture_ != NULL) delete next_screen_capture_;
  next_screen_capture_ = NULL;
}
inline const ::proto::internal::NextScreenCapture& ServiceToDesktop::next_screen_capture() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.next_screen_capture)
  return next_screen_capture_ != NULL ? *next_screen_capture_
                         : *::proto::internal::NextScreenCapture::internal_default_instance();
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::mutable_next_screen_capture() {
  
  if (next_screen_capture_ == NULL) {
    next_screen_capture_ = new ::proto::internal::NextScreenCapture;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.next_screen_capture)
  return next_screen_capture_;
}
inline ::proto::internal::NextScreenCapture* ServiceToDesktop::release_next_screen_capture() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.next_screen_capture)
  
  ::proto::internal::NextScreenCapture* temp = next_screen_capture_;
  next_screen_capture_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_next_screen_capture(::proto::internal::NextScreenCapture* next_screen_capture) {
  delete next_screen_capture_;
  next_screen_capture_ = next_screen_capture;
  if (next_screen_capture) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.next_screen_capture)
}

// .proto.KeyEvent key_event = 5;
inline bool ServiceToDesktop::has_key_event() const {
  return this != internal_default_instance() && key_event_ != NULL;
}
inline void ServiceToDesktop::clear_key_event() {
  if (GetArenaNoVirtual() == NULL && key_event_ != NULL) delete key_event_;
  key_event_ = NULL;
}
inline const ::proto::KeyEvent& ServiceToDesktop::key_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.key_event)
  return key_event_ != NULL ? *key_event_
                         : *::proto::KeyEvent::internal_default_instance();
}
inline ::proto::KeyEvent* ServiceToDesktop::mutable_key_event() {
  
  if (key_event_ == NULL) {
    key_event_ = new ::proto::KeyEvent;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.key_event)
  return key_event_;
}
inline ::proto::KeyEvent* ServiceToDesktop::release_key_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.key_event)
  
  ::proto::KeyEvent* temp = key_event_;
  key_event_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_key_event(::proto::KeyEvent* key_event) {
  delete key_event_;
  key_event_ = key_event;
  if (key_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.key_event)
}

// .proto.MouseEvent mouse_event = 6;
inline bool ServiceToDesktop::has_mouse_event() const {
  return this != internal_default_instance() && mouse_event_ != NULL;
}
inline void ServiceToDesktop::clear_mouse_event() {
  if (GetArenaNoVirtual() == NULL && mouse_event_ != NULL) delete mouse_event_;
  mouse_event_ = NULL;
}
inline const ::proto::MouseEvent& ServiceToDesktop::mouse_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.mouse_event)
  return mouse_event_ != NULL ? *mouse_event_
                         : *::proto::MouseEvent::internal_default_instance();
}
inline ::proto::MouseEvent* ServiceToDesktop::mutable_mouse_event() {
  
  if (mouse_event_ == NULL) {
    mouse_event_ = new ::proto::MouseEvent;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.mouse_event)
  return mouse_event_;
}
inline ::proto::MouseEvent* ServiceToDesktop::release_mouse_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.mouse_event)
  
  ::proto::MouseEvent* temp = mouse_event_;
  mouse_event_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_mouse_event(::proto::MouseEvent* mouse_event) {
  delete mouse_event_;
  mouse_event_ = mouse_event;
  if (mouse_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.mouse_event)
}

// .proto.ClipboardEvent clipboard_event = 7;
inline bool ServiceToDesktop::has_clipboard_event() const {
  return this != internal_default_instance() && clipboard_event_ != NULL;
}
inline void ServiceToDesktop::clear_clipboard_event() {
  if (GetArenaNoVirtual() == NULL && clipboard_event_ != NULL) delete clipboard_event_;
  clipboard_event_ = NULL;
}
inline const ::proto::ClipboardEvent& ServiceToDesktop::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.ServiceToDesktop.clipboard_event)
  return clipboard_event_ != NULL ? *clipboard_event_
                         : *::proto::ClipboardEvent::internal_default_instance();
}
inline ::proto::ClipboardEvent* ServiceToDesktop::mutable_clipboard_event() {
  
  if (clipboard_event_ == NULL) {
    clipboard_event_ = new ::proto::ClipboardEvent;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.ServiceToDesktop.clipboard_event)
  return clipboard_event_;
}
inline ::proto::ClipboardEvent* ServiceToDesktop::release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.internal.ServiceToDesktop.clipboard_event)
  
  ::proto::ClipboardEvent* temp = clipboard_event_;
  clipboard_event_ = NULL;
  return temp;
}
inline void ServiceToDesktop::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  delete clipboard_event_;
  clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.ServiceToDesktop.clipboard_event)
}

// -------------------------------------------------------------------

// DesktopToService

// .proto.ScreenList screen_list = 1;
inline bool DesktopToService::has_screen_list() const {
  return this != internal_default_instance() && screen_list_ != NULL;
}
inline void DesktopToService::clear_screen_list() {
  if (GetArenaNoVirtual() == NULL && screen_list_ != NULL) delete screen_list_;
  screen_list_ = NULL;
}
inline const ::proto::ScreenList& DesktopToService::screen_list() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.screen_list)
  return screen_list_ != NULL ? *screen_list_
                         : *::proto::ScreenList::internal_default_instance();
}
inline ::proto::ScreenList* DesktopToService::mutable_screen_list() {
  
  if (screen_list_ == NULL) {
    screen_list_ = new ::proto::ScreenList;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.screen_list)
  return screen_list_;
}
inline ::proto::ScreenList* DesktopToService::release_screen_list() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.screen_list)
  
  ::proto::ScreenList* temp = screen_list_;
  screen_list_ = NULL;
  return temp;
}
inline void DesktopToService::set_allocated_screen_list(::proto::ScreenList* screen_list) {
  delete screen_list_;
  screen_list_ = screen_list;
  if (screen_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.screen_list)
}

// .proto.internal.SharedBuffer shared_buffer = 2;
inline bool DesktopToService::has_shared_buffer() const {
  return this != internal_default_instance() && shared_buffer_ != NULL;
}
inline void DesktopToService::clear_shared_buffer() {
  if (GetArenaNoVirtual() == NULL && shared_buffer_ != NULL) delete shared_buffer_;
  shared_buffer_ = NULL;
}
inline const ::proto::internal::SharedBuffer& DesktopToService::shared_buffer() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.shared_buffer)
  return shared_buffer_ != NULL ? *shared_buffer_
                         : *::proto::internal::SharedBuffer::internal_default_instance();
}
inline ::proto::internal::SharedBuffer* DesktopToService::mutable_shared_buffer() {
  
  if (shared_buffer_ == NULL) {
    shared_buffer_ = new ::proto::internal::SharedBuffer;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.shared_buffer)
  return shared_buffer_;
}
inline ::proto::internal::SharedBuffer* DesktopToService::release_shared_buffer() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.shared_buffer)
  
  ::proto::internal::SharedBuffer* temp = shared_buffer_;
  shared_buffer_ = NULL;
  return temp;
}
inline void DesktopToService::set_allocated_shared_buffer(::proto::internal::SharedBuffer* shared_buffer) {
  delete shared_buffer_;
  shared_buffer_ = shared_buffer;
  if (shared_buffer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.shared_buffer)
}

// .proto.internal.ScreenCaptured screen_captured = 3;
inline bool DesktopToService::has_screen_captured() const {
  return this != internal_default_instance() && screen_captured_ != NULL;
}
inline void DesktopToService::clear_screen_captured() {
  if (GetArenaNoVirtual() == NULL && screen_captured_ != NULL) delete screen_captured_;
  screen_captured_ = NULL;
}
inline const ::proto::internal::ScreenCaptured& DesktopToService::screen_captured() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.screen_captured)
  return screen_captured_ != NULL ? *screen_captured_
                         : *::proto::internal::ScreenCaptured::internal_default_instance();
}
inline ::proto::internal::ScreenCaptured* DesktopToService::mutable_screen_captured() {
  
  if (screen_captured_ == NULL) {
    screen_captured_ = new ::proto::internal::ScreenCaptured;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.screen_captured)
  return screen_captured_;
}
inline ::proto::internal::ScreenCaptured* DesktopToService::release_screen_captured() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.screen_captured)
  
  ::proto::internal::ScreenCaptured* temp = screen_captured_;
  screen_captured_ = NULL;
  return temp;
}
inline void DesktopToService::set_allocated_screen_captured(::proto::internal::ScreenCaptured* screen_captured) {
  delete screen_captured_;
  screen_captured_ = screen_captured;
  if (screen_captured) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.screen_captured)
}

// .proto.AudioPacket audio_packet = 4;
inline bool DesktopToService::has_audio_packet() const {
  return this != internal_default_instance() && audio_packet_ != NULL;
}
inline void DesktopToService::clear_audio_packet() {
  if (GetArenaNoVirtual() == NULL && audio_packet_ != NULL) delete audio_packet_;
  audio_packet_ = NULL;
}
inline const ::proto::AudioPacket& DesktopToService::audio_packet() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.audio_packet)
  return audio_packet_ != NULL ? *audio_packet_
                         : *::proto::AudioPacket::internal_default_instance();
}
inline ::proto::AudioPacket* DesktopToService::mutable_audio_packet() {
  
  if (audio_packet_ == NULL) {
    audio_packet_ = new ::proto::AudioPacket;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.audio_packet)
  return audio_packet_;
}
inline ::proto::AudioPacket* DesktopToService::release_audio_packet() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.audio_packet)
  
  ::proto::AudioPacket* temp = audio_packet_;
  audio_packet_ = NULL;
  return temp;
}
inline void DesktopToService::set_allocated_audio_packet(::proto::AudioPacket* audio_packet) {
  delete audio_packet_;
  audio_packet_ = audio_packet;
  if (audio_packet) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.audio_packet)
}

// .proto.ClipboardEvent clipboard_event = 5;
inline bool DesktopToService::has_clipboard_event() const {
  return this != internal_default_instance() && clipboard_event_ != NULL;
}
inline void DesktopToService::clear_clipboard_event() {
  if (GetArenaNoVirtual() == NULL && clipboard_event_ != NULL) delete clipboard_event_;
  clipboard_event_ = NULL;
}
inline const ::proto::ClipboardEvent& DesktopToService::clipboard_event() const {
  // @@protoc_insertion_point(field_get:proto.internal.DesktopToService.clipboard_event)
  return clipboard_event_ != NULL ? *clipboard_event_
                         : *::proto::ClipboardEvent::internal_default_instance();
}
inline ::proto::ClipboardEvent* DesktopToService::mutable_clipboard_event() {
  
  if (clipboard_event_ == NULL) {
    clipboard_event_ = new ::proto::ClipboardEvent;
  }
  // @@protoc_insertion_point(field_mutable:proto.internal.DesktopToService.clipboard_event)
  return clipboard_event_;
}
inline ::proto::ClipboardEvent* DesktopToService::release_clipboard_event() {
  // @@protoc_insertion_point(field_release:proto.internal.DesktopToService.clipboard_event)
  
  ::proto::ClipboardEvent* temp = clipboard_event_;
  clipboard_event_ = NULL;
  return temp;
}
inline void DesktopToService::set_allocated_clipboard_event(::proto::ClipboardEvent* clipboard_event) {
  delete clipboard_event_;
  clipboard_event_ = clipboard_event;
  if (clipboard_event) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.internal.DesktopToService.clipboard_event)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace internal
}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::internal::SharedBuffer_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::internal::Control_Action> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_desktop_5finternal_2eproto__INCLUDED
