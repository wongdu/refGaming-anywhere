// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: desktop_extensions.proto

#ifndef PROTOBUF_desktop_5fextensions_2eproto__INCLUDED
#define PROTOBUF_desktop_5fextensions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "system_info.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
class PowerControl;
class PowerControlDefaultTypeInternal;
extern PowerControlDefaultTypeInternal _PowerControl_default_instance_;
class PreferredSize;
class PreferredSizeDefaultTypeInternal;
extern PreferredSizeDefaultTypeInternal _PreferredSize_default_instance_;
class Screen;
class ScreenDefaultTypeInternal;
extern ScreenDefaultTypeInternal _Screen_default_instance_;
class ScreenList;
class ScreenListDefaultTypeInternal;
extern ScreenListDefaultTypeInternal _ScreenList_default_instance_;
class SystemInfo;
class SystemInfoDefaultTypeInternal;
extern SystemInfoDefaultTypeInternal _SystemInfo_default_instance_;
namespace system_info {
class Bios;
class BiosDefaultTypeInternal;
extern BiosDefaultTypeInternal _Bios_default_instance_;
class Computer;
class ComputerDefaultTypeInternal;
extern ComputerDefaultTypeInternal _Computer_default_instance_;
class LogicalDrives;
class LogicalDrivesDefaultTypeInternal;
extern LogicalDrivesDefaultTypeInternal _LogicalDrives_default_instance_;
class LogicalDrives_Drive;
class LogicalDrives_DriveDefaultTypeInternal;
extern LogicalDrives_DriveDefaultTypeInternal _LogicalDrives_Drive_default_instance_;
class Memory;
class MemoryDefaultTypeInternal;
extern MemoryDefaultTypeInternal _Memory_default_instance_;
class Memory_Module;
class Memory_ModuleDefaultTypeInternal;
extern Memory_ModuleDefaultTypeInternal _Memory_Module_default_instance_;
class Motherboard;
class MotherboardDefaultTypeInternal;
extern MotherboardDefaultTypeInternal _Motherboard_default_instance_;
class NetworkAdapters;
class NetworkAdaptersDefaultTypeInternal;
extern NetworkAdaptersDefaultTypeInternal _NetworkAdapters_default_instance_;
class NetworkAdapters_Adapter;
class NetworkAdapters_AdapterDefaultTypeInternal;
extern NetworkAdapters_AdapterDefaultTypeInternal _NetworkAdapters_Adapter_default_instance_;
class NetworkAdapters_Adapter_Address;
class NetworkAdapters_Adapter_AddressDefaultTypeInternal;
extern NetworkAdapters_Adapter_AddressDefaultTypeInternal _NetworkAdapters_Adapter_Address_default_instance_;
class OperatingSystem;
class OperatingSystemDefaultTypeInternal;
extern OperatingSystemDefaultTypeInternal _OperatingSystem_default_instance_;
class Printers;
class PrintersDefaultTypeInternal;
extern PrintersDefaultTypeInternal _Printers_default_instance_;
class Printers_Printer;
class Printers_PrinterDefaultTypeInternal;
extern Printers_PrinterDefaultTypeInternal _Printers_Printer_default_instance_;
class Processor;
class ProcessorDefaultTypeInternal;
extern ProcessorDefaultTypeInternal _Processor_default_instance_;
}  // namespace system_info
}  // namespace proto

namespace proto {

namespace protobuf_desktop_5fextensions_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_desktop_5fextensions_2eproto

enum PowerControl_Action {
  PowerControl_Action_ACTION_UNKNOWN = 0,
  PowerControl_Action_ACTION_SHUTDOWN = 1,
  PowerControl_Action_ACTION_REBOOT = 2,
  PowerControl_Action_ACTION_LOGOFF = 3,
  PowerControl_Action_ACTION_LOCK = 4,
  PowerControl_Action_PowerControl_Action_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PowerControl_Action_PowerControl_Action_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PowerControl_Action_IsValid(int value);
const PowerControl_Action PowerControl_Action_Action_MIN = PowerControl_Action_ACTION_UNKNOWN;
const PowerControl_Action PowerControl_Action_Action_MAX = PowerControl_Action_ACTION_LOCK;
const int PowerControl_Action_Action_ARRAYSIZE = PowerControl_Action_Action_MAX + 1;

// ===================================================================

class Screen : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Screen) */ {
 public:
  Screen();
  virtual ~Screen();

  Screen(const Screen& from);

  inline Screen& operator=(const Screen& from) {
    CopyFrom(from);
    return *this;
  }

  static const Screen& default_instance();

  static inline const Screen* internal_default_instance() {
    return reinterpret_cast<const Screen*>(
               &_Screen_default_instance_);
  }

  void Swap(Screen* other);

  // implements Message ----------------------------------------------

  inline Screen* New() const PROTOBUF_FINAL { return New(NULL); }

  Screen* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Screen& from);
  void MergeFrom(const Screen& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Screen* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.Screen)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5fextensions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScreenList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ScreenList) */ {
 public:
  ScreenList();
  virtual ~ScreenList();

  ScreenList(const ScreenList& from);

  inline ScreenList& operator=(const ScreenList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScreenList& default_instance();

  static inline const ScreenList* internal_default_instance() {
    return reinterpret_cast<const ScreenList*>(
               &_ScreenList_default_instance_);
  }

  void Swap(ScreenList* other);

  // implements Message ----------------------------------------------

  inline ScreenList* New() const PROTOBUF_FINAL { return New(NULL); }

  ScreenList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ScreenList& from);
  void MergeFrom(const ScreenList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ScreenList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .proto.Screen screen = 1;
  int screen_size() const;
  void clear_screen();
  static const int kScreenFieldNumber = 1;
  const ::proto::Screen& screen(int index) const;
  ::proto::Screen* mutable_screen(int index);
  ::proto::Screen* add_screen();
  ::google::protobuf::RepeatedPtrField< ::proto::Screen >*
      mutable_screen();
  const ::google::protobuf::RepeatedPtrField< ::proto::Screen >&
      screen() const;

  // int64 current_screen = 2;
  void clear_current_screen();
  static const int kCurrentScreenFieldNumber = 2;
  ::google::protobuf::int64 current_screen() const;
  void set_current_screen(::google::protobuf::int64 value);

  // int64 primary_screen = 3;
  void clear_primary_screen();
  static const int kPrimaryScreenFieldNumber = 3;
  ::google::protobuf::int64 primary_screen() const;
  void set_primary_screen(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.ScreenList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Screen > screen_;
  ::google::protobuf::int64 current_screen_;
  ::google::protobuf::int64 primary_screen_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5fextensions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreferredSize : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.PreferredSize) */ {
 public:
  PreferredSize();
  virtual ~PreferredSize();

  PreferredSize(const PreferredSize& from);

  inline PreferredSize& operator=(const PreferredSize& from) {
    CopyFrom(from);
    return *this;
  }

  static const PreferredSize& default_instance();

  static inline const PreferredSize* internal_default_instance() {
    return reinterpret_cast<const PreferredSize*>(
               &_PreferredSize_default_instance_);
  }

  void Swap(PreferredSize* other);

  // implements Message ----------------------------------------------

  inline PreferredSize* New() const PROTOBUF_FINAL { return New(NULL); }

  PreferredSize* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PreferredSize& from);
  void MergeFrom(const PreferredSize& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PreferredSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // int32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:proto.PreferredSize)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5fextensions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PowerControl : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.PowerControl) */ {
 public:
  PowerControl();
  virtual ~PowerControl();

  PowerControl(const PowerControl& from);

  inline PowerControl& operator=(const PowerControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const PowerControl& default_instance();

  static inline const PowerControl* internal_default_instance() {
    return reinterpret_cast<const PowerControl*>(
               &_PowerControl_default_instance_);
  }

  void Swap(PowerControl* other);

  // implements Message ----------------------------------------------

  inline PowerControl* New() const PROTOBUF_FINAL { return New(NULL); }

  PowerControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PowerControl& from);
  void MergeFrom(const PowerControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PowerControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef PowerControl_Action Action;
  static const Action ACTION_UNKNOWN =
    PowerControl_Action_ACTION_UNKNOWN;
  static const Action ACTION_SHUTDOWN =
    PowerControl_Action_ACTION_SHUTDOWN;
  static const Action ACTION_REBOOT =
    PowerControl_Action_ACTION_REBOOT;
  static const Action ACTION_LOGOFF =
    PowerControl_Action_ACTION_LOGOFF;
  static const Action ACTION_LOCK =
    PowerControl_Action_ACTION_LOCK;
  static inline bool Action_IsValid(int value) {
    return PowerControl_Action_IsValid(value);
  }
  static const Action Action_MIN =
    PowerControl_Action_Action_MIN;
  static const Action Action_MAX =
    PowerControl_Action_Action_MAX;
  static const int Action_ARRAYSIZE =
    PowerControl_Action_Action_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.PowerControl.Action action = 1;
  void clear_action();
  static const int kActionFieldNumber = 1;
  ::proto::PowerControl_Action action() const;
  void set_action(::proto::PowerControl_Action value);

  // @@protoc_insertion_point(class_scope:proto.PowerControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int action_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5fextensions_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SystemInfo) */ {
 public:
  SystemInfo();
  virtual ~SystemInfo();

  SystemInfo(const SystemInfo& from);

  inline SystemInfo& operator=(const SystemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const SystemInfo& default_instance();

  static inline const SystemInfo* internal_default_instance() {
    return reinterpret_cast<const SystemInfo*>(
               &_SystemInfo_default_instance_);
  }

  void Swap(SystemInfo* other);

  // implements Message ----------------------------------------------

  inline SystemInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SystemInfo& from);
  void MergeFrom(const SystemInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SystemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.system_info.Computer computer = 1;
  bool has_computer() const;
  void clear_computer();
  static const int kComputerFieldNumber = 1;
  const ::proto::system_info::Computer& computer() const;
  ::proto::system_info::Computer* mutable_computer();
  ::proto::system_info::Computer* release_computer();
  void set_allocated_computer(::proto::system_info::Computer* computer);

  // .proto.system_info.OperatingSystem operating_system = 2;
  bool has_operating_system() const;
  void clear_operating_system();
  static const int kOperatingSystemFieldNumber = 2;
  const ::proto::system_info::OperatingSystem& operating_system() const;
  ::proto::system_info::OperatingSystem* mutable_operating_system();
  ::proto::system_info::OperatingSystem* release_operating_system();
  void set_allocated_operating_system(::proto::system_info::OperatingSystem* operating_system);

  // .proto.system_info.Motherboard motherboard = 3;
  bool has_motherboard() const;
  void clear_motherboard();
  static const int kMotherboardFieldNumber = 3;
  const ::proto::system_info::Motherboard& motherboard() const;
  ::proto::system_info::Motherboard* mutable_motherboard();
  ::proto::system_info::Motherboard* release_motherboard();
  void set_allocated_motherboard(::proto::system_info::Motherboard* motherboard);

  // .proto.system_info.Bios bios = 4;
  bool has_bios() const;
  void clear_bios();
  static const int kBiosFieldNumber = 4;
  const ::proto::system_info::Bios& bios() const;
  ::proto::system_info::Bios* mutable_bios();
  ::proto::system_info::Bios* release_bios();
  void set_allocated_bios(::proto::system_info::Bios* bios);

  // .proto.system_info.Processor processor = 5;
  bool has_processor() const;
  void clear_processor();
  static const int kProcessorFieldNumber = 5;
  const ::proto::system_info::Processor& processor() const;
  ::proto::system_info::Processor* mutable_processor();
  ::proto::system_info::Processor* release_processor();
  void set_allocated_processor(::proto::system_info::Processor* processor);

  // .proto.system_info.Memory memory = 6;
  bool has_memory() const;
  void clear_memory();
  static const int kMemoryFieldNumber = 6;
  const ::proto::system_info::Memory& memory() const;
  ::proto::system_info::Memory* mutable_memory();
  ::proto::system_info::Memory* release_memory();
  void set_allocated_memory(::proto::system_info::Memory* memory);

  // .proto.system_info.LogicalDrives logical_drives = 7;
  bool has_logical_drives() const;
  void clear_logical_drives();
  static const int kLogicalDrivesFieldNumber = 7;
  const ::proto::system_info::LogicalDrives& logical_drives() const;
  ::proto::system_info::LogicalDrives* mutable_logical_drives();
  ::proto::system_info::LogicalDrives* release_logical_drives();
  void set_allocated_logical_drives(::proto::system_info::LogicalDrives* logical_drives);

  // .proto.system_info.Printers printers = 8;
  bool has_printers() const;
  void clear_printers();
  static const int kPrintersFieldNumber = 8;
  const ::proto::system_info::Printers& printers() const;
  ::proto::system_info::Printers* mutable_printers();
  ::proto::system_info::Printers* release_printers();
  void set_allocated_printers(::proto::system_info::Printers* printers);

  // .proto.system_info.NetworkAdapters network_adapters = 9;
  bool has_network_adapters() const;
  void clear_network_adapters();
  static const int kNetworkAdaptersFieldNumber = 9;
  const ::proto::system_info::NetworkAdapters& network_adapters() const;
  ::proto::system_info::NetworkAdapters* mutable_network_adapters();
  ::proto::system_info::NetworkAdapters* release_network_adapters();
  void set_allocated_network_adapters(::proto::system_info::NetworkAdapters* network_adapters);

  // @@protoc_insertion_point(class_scope:proto.SystemInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::system_info::Computer* computer_;
  ::proto::system_info::OperatingSystem* operating_system_;
  ::proto::system_info::Motherboard* motherboard_;
  ::proto::system_info::Bios* bios_;
  ::proto::system_info::Processor* processor_;
  ::proto::system_info::Memory* memory_;
  ::proto::system_info::LogicalDrives* logical_drives_;
  ::proto::system_info::Printers* printers_;
  ::proto::system_info::NetworkAdapters* network_adapters_;
  mutable int _cached_size_;
  friend struct  protobuf_desktop_5fextensions_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Screen

// int64 id = 1;
inline void Screen::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Screen::id() const {
  // @@protoc_insertion_point(field_get:proto.Screen.id)
  return id_;
}
inline void Screen::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:proto.Screen.id)
}

// string title = 2;
inline void Screen::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Screen::title() const {
  // @@protoc_insertion_point(field_get:proto.Screen.title)
  return title_.GetNoArena();
}
inline void Screen::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Screen.title)
}
#if LANG_CXX11
inline void Screen::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Screen.title)
}
#endif
inline void Screen::set_title(const char* value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Screen.title)
}
inline void Screen::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Screen.title)
}
inline ::std::string* Screen::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:proto.Screen.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Screen::release_title() {
  // @@protoc_insertion_point(field_release:proto.Screen.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Screen::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:proto.Screen.title)
}

// -------------------------------------------------------------------

// ScreenList

// repeated .proto.Screen screen = 1;
inline int ScreenList::screen_size() const {
  return screen_.size();
}
inline void ScreenList::clear_screen() {
  screen_.Clear();
}
inline const ::proto::Screen& ScreenList::screen(int index) const {
  // @@protoc_insertion_point(field_get:proto.ScreenList.screen)
  return screen_.Get(index);
}
inline ::proto::Screen* ScreenList::mutable_screen(int index) {
  // @@protoc_insertion_point(field_mutable:proto.ScreenList.screen)
  return screen_.Mutable(index);
}
inline ::proto::Screen* ScreenList::add_screen() {
  // @@protoc_insertion_point(field_add:proto.ScreenList.screen)
  return screen_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Screen >*
ScreenList::mutable_screen() {
  // @@protoc_insertion_point(field_mutable_list:proto.ScreenList.screen)
  return &screen_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Screen >&
ScreenList::screen() const {
  // @@protoc_insertion_point(field_list:proto.ScreenList.screen)
  return screen_;
}

// int64 current_screen = 2;
inline void ScreenList::clear_current_screen() {
  current_screen_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ScreenList::current_screen() const {
  // @@protoc_insertion_point(field_get:proto.ScreenList.current_screen)
  return current_screen_;
}
inline void ScreenList::set_current_screen(::google::protobuf::int64 value) {
  
  current_screen_ = value;
  // @@protoc_insertion_point(field_set:proto.ScreenList.current_screen)
}

// int64 primary_screen = 3;
inline void ScreenList::clear_primary_screen() {
  primary_screen_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ScreenList::primary_screen() const {
  // @@protoc_insertion_point(field_get:proto.ScreenList.primary_screen)
  return primary_screen_;
}
inline void ScreenList::set_primary_screen(::google::protobuf::int64 value) {
  
  primary_screen_ = value;
  // @@protoc_insertion_point(field_set:proto.ScreenList.primary_screen)
}

// -------------------------------------------------------------------

// PreferredSize

// int32 width = 1;
inline void PreferredSize::clear_width() {
  width_ = 0;
}
inline ::google::protobuf::int32 PreferredSize::width() const {
  // @@protoc_insertion_point(field_get:proto.PreferredSize.width)
  return width_;
}
inline void PreferredSize::set_width(::google::protobuf::int32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:proto.PreferredSize.width)
}

// int32 height = 2;
inline void PreferredSize::clear_height() {
  height_ = 0;
}
inline ::google::protobuf::int32 PreferredSize::height() const {
  // @@protoc_insertion_point(field_get:proto.PreferredSize.height)
  return height_;
}
inline void PreferredSize::set_height(::google::protobuf::int32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:proto.PreferredSize.height)
}

// -------------------------------------------------------------------

// PowerControl

// .proto.PowerControl.Action action = 1;
inline void PowerControl::clear_action() {
  action_ = 0;
}
inline ::proto::PowerControl_Action PowerControl::action() const {
  // @@protoc_insertion_point(field_get:proto.PowerControl.action)
  return static_cast< ::proto::PowerControl_Action >(action_);
}
inline void PowerControl::set_action(::proto::PowerControl_Action value) {
  
  action_ = value;
  // @@protoc_insertion_point(field_set:proto.PowerControl.action)
}

// -------------------------------------------------------------------

// SystemInfo

// .proto.system_info.Computer computer = 1;
inline bool SystemInfo::has_computer() const {
  return this != internal_default_instance() && computer_ != NULL;
}
inline void SystemInfo::clear_computer() {
  if (GetArenaNoVirtual() == NULL && computer_ != NULL) delete computer_;
  computer_ = NULL;
}
inline const ::proto::system_info::Computer& SystemInfo::computer() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.computer)
  return computer_ != NULL ? *computer_
                         : *::proto::system_info::Computer::internal_default_instance();
}
inline ::proto::system_info::Computer* SystemInfo::mutable_computer() {
  
  if (computer_ == NULL) {
    computer_ = new ::proto::system_info::Computer;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.computer)
  return computer_;
}
inline ::proto::system_info::Computer* SystemInfo::release_computer() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.computer)
  
  ::proto::system_info::Computer* temp = computer_;
  computer_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_computer(::proto::system_info::Computer* computer) {
  delete computer_;
  computer_ = computer;
  if (computer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.computer)
}

// .proto.system_info.OperatingSystem operating_system = 2;
inline bool SystemInfo::has_operating_system() const {
  return this != internal_default_instance() && operating_system_ != NULL;
}
inline void SystemInfo::clear_operating_system() {
  if (GetArenaNoVirtual() == NULL && operating_system_ != NULL) delete operating_system_;
  operating_system_ = NULL;
}
inline const ::proto::system_info::OperatingSystem& SystemInfo::operating_system() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.operating_system)
  return operating_system_ != NULL ? *operating_system_
                         : *::proto::system_info::OperatingSystem::internal_default_instance();
}
inline ::proto::system_info::OperatingSystem* SystemInfo::mutable_operating_system() {
  
  if (operating_system_ == NULL) {
    operating_system_ = new ::proto::system_info::OperatingSystem;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.operating_system)
  return operating_system_;
}
inline ::proto::system_info::OperatingSystem* SystemInfo::release_operating_system() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.operating_system)
  
  ::proto::system_info::OperatingSystem* temp = operating_system_;
  operating_system_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_operating_system(::proto::system_info::OperatingSystem* operating_system) {
  delete operating_system_;
  operating_system_ = operating_system;
  if (operating_system) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.operating_system)
}

// .proto.system_info.Motherboard motherboard = 3;
inline bool SystemInfo::has_motherboard() const {
  return this != internal_default_instance() && motherboard_ != NULL;
}
inline void SystemInfo::clear_motherboard() {
  if (GetArenaNoVirtual() == NULL && motherboard_ != NULL) delete motherboard_;
  motherboard_ = NULL;
}
inline const ::proto::system_info::Motherboard& SystemInfo::motherboard() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.motherboard)
  return motherboard_ != NULL ? *motherboard_
                         : *::proto::system_info::Motherboard::internal_default_instance();
}
inline ::proto::system_info::Motherboard* SystemInfo::mutable_motherboard() {
  
  if (motherboard_ == NULL) {
    motherboard_ = new ::proto::system_info::Motherboard;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.motherboard)
  return motherboard_;
}
inline ::proto::system_info::Motherboard* SystemInfo::release_motherboard() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.motherboard)
  
  ::proto::system_info::Motherboard* temp = motherboard_;
  motherboard_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_motherboard(::proto::system_info::Motherboard* motherboard) {
  delete motherboard_;
  motherboard_ = motherboard;
  if (motherboard) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.motherboard)
}

// .proto.system_info.Bios bios = 4;
inline bool SystemInfo::has_bios() const {
  return this != internal_default_instance() && bios_ != NULL;
}
inline void SystemInfo::clear_bios() {
  if (GetArenaNoVirtual() == NULL && bios_ != NULL) delete bios_;
  bios_ = NULL;
}
inline const ::proto::system_info::Bios& SystemInfo::bios() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.bios)
  return bios_ != NULL ? *bios_
                         : *::proto::system_info::Bios::internal_default_instance();
}
inline ::proto::system_info::Bios* SystemInfo::mutable_bios() {
  
  if (bios_ == NULL) {
    bios_ = new ::proto::system_info::Bios;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.bios)
  return bios_;
}
inline ::proto::system_info::Bios* SystemInfo::release_bios() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.bios)
  
  ::proto::system_info::Bios* temp = bios_;
  bios_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_bios(::proto::system_info::Bios* bios) {
  delete bios_;
  bios_ = bios;
  if (bios) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.bios)
}

// .proto.system_info.Processor processor = 5;
inline bool SystemInfo::has_processor() const {
  return this != internal_default_instance() && processor_ != NULL;
}
inline void SystemInfo::clear_processor() {
  if (GetArenaNoVirtual() == NULL && processor_ != NULL) delete processor_;
  processor_ = NULL;
}
inline const ::proto::system_info::Processor& SystemInfo::processor() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.processor)
  return processor_ != NULL ? *processor_
                         : *::proto::system_info::Processor::internal_default_instance();
}
inline ::proto::system_info::Processor* SystemInfo::mutable_processor() {
  
  if (processor_ == NULL) {
    processor_ = new ::proto::system_info::Processor;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.processor)
  return processor_;
}
inline ::proto::system_info::Processor* SystemInfo::release_processor() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.processor)
  
  ::proto::system_info::Processor* temp = processor_;
  processor_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_processor(::proto::system_info::Processor* processor) {
  delete processor_;
  processor_ = processor;
  if (processor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.processor)
}

// .proto.system_info.Memory memory = 6;
inline bool SystemInfo::has_memory() const {
  return this != internal_default_instance() && memory_ != NULL;
}
inline void SystemInfo::clear_memory() {
  if (GetArenaNoVirtual() == NULL && memory_ != NULL) delete memory_;
  memory_ = NULL;
}
inline const ::proto::system_info::Memory& SystemInfo::memory() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.memory)
  return memory_ != NULL ? *memory_
                         : *::proto::system_info::Memory::internal_default_instance();
}
inline ::proto::system_info::Memory* SystemInfo::mutable_memory() {
  
  if (memory_ == NULL) {
    memory_ = new ::proto::system_info::Memory;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.memory)
  return memory_;
}
inline ::proto::system_info::Memory* SystemInfo::release_memory() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.memory)
  
  ::proto::system_info::Memory* temp = memory_;
  memory_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_memory(::proto::system_info::Memory* memory) {
  delete memory_;
  memory_ = memory;
  if (memory) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.memory)
}

// .proto.system_info.LogicalDrives logical_drives = 7;
inline bool SystemInfo::has_logical_drives() const {
  return this != internal_default_instance() && logical_drives_ != NULL;
}
inline void SystemInfo::clear_logical_drives() {
  if (GetArenaNoVirtual() == NULL && logical_drives_ != NULL) delete logical_drives_;
  logical_drives_ = NULL;
}
inline const ::proto::system_info::LogicalDrives& SystemInfo::logical_drives() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.logical_drives)
  return logical_drives_ != NULL ? *logical_drives_
                         : *::proto::system_info::LogicalDrives::internal_default_instance();
}
inline ::proto::system_info::LogicalDrives* SystemInfo::mutable_logical_drives() {
  
  if (logical_drives_ == NULL) {
    logical_drives_ = new ::proto::system_info::LogicalDrives;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.logical_drives)
  return logical_drives_;
}
inline ::proto::system_info::LogicalDrives* SystemInfo::release_logical_drives() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.logical_drives)
  
  ::proto::system_info::LogicalDrives* temp = logical_drives_;
  logical_drives_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_logical_drives(::proto::system_info::LogicalDrives* logical_drives) {
  delete logical_drives_;
  logical_drives_ = logical_drives;
  if (logical_drives) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.logical_drives)
}

// .proto.system_info.Printers printers = 8;
inline bool SystemInfo::has_printers() const {
  return this != internal_default_instance() && printers_ != NULL;
}
inline void SystemInfo::clear_printers() {
  if (GetArenaNoVirtual() == NULL && printers_ != NULL) delete printers_;
  printers_ = NULL;
}
inline const ::proto::system_info::Printers& SystemInfo::printers() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.printers)
  return printers_ != NULL ? *printers_
                         : *::proto::system_info::Printers::internal_default_instance();
}
inline ::proto::system_info::Printers* SystemInfo::mutable_printers() {
  
  if (printers_ == NULL) {
    printers_ = new ::proto::system_info::Printers;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.printers)
  return printers_;
}
inline ::proto::system_info::Printers* SystemInfo::release_printers() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.printers)
  
  ::proto::system_info::Printers* temp = printers_;
  printers_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_printers(::proto::system_info::Printers* printers) {
  delete printers_;
  printers_ = printers;
  if (printers) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.printers)
}

// .proto.system_info.NetworkAdapters network_adapters = 9;
inline bool SystemInfo::has_network_adapters() const {
  return this != internal_default_instance() && network_adapters_ != NULL;
}
inline void SystemInfo::clear_network_adapters() {
  if (GetArenaNoVirtual() == NULL && network_adapters_ != NULL) delete network_adapters_;
  network_adapters_ = NULL;
}
inline const ::proto::system_info::NetworkAdapters& SystemInfo::network_adapters() const {
  // @@protoc_insertion_point(field_get:proto.SystemInfo.network_adapters)
  return network_adapters_ != NULL ? *network_adapters_
                         : *::proto::system_info::NetworkAdapters::internal_default_instance();
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::mutable_network_adapters() {
  
  if (network_adapters_ == NULL) {
    network_adapters_ = new ::proto::system_info::NetworkAdapters;
  }
  // @@protoc_insertion_point(field_mutable:proto.SystemInfo.network_adapters)
  return network_adapters_;
}
inline ::proto::system_info::NetworkAdapters* SystemInfo::release_network_adapters() {
  // @@protoc_insertion_point(field_release:proto.SystemInfo.network_adapters)
  
  ::proto::system_info::NetworkAdapters* temp = network_adapters_;
  network_adapters_ = NULL;
  return temp;
}
inline void SystemInfo::set_allocated_network_adapters(::proto::system_info::NetworkAdapters* network_adapters) {
  delete network_adapters_;
  network_adapters_ = network_adapters;
  if (network_adapters) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SystemInfo.network_adapters)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::PowerControl_Action> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_desktop_5fextensions_2eproto__INCLUDED
