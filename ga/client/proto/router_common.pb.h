// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_common.proto

#ifndef PROTOBUF_router_5fcommon_2eproto__INCLUDED
#define PROTOBUF_router_5fcommon_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace proto {
class RelayCredentials;
class RelayCredentialsDefaultTypeInternal;
extern RelayCredentialsDefaultTypeInternal _RelayCredentials_default_instance_;
class RelayKey;
class RelayKeyDefaultTypeInternal;
extern RelayKeyDefaultTypeInternal _RelayKey_default_instance_;
}  // namespace proto

namespace proto {

namespace protobuf_router_5fcommon_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_router_5fcommon_2eproto

enum RelayKey_Type {
  RelayKey_Type_TYPE_UNKNOWN = 0,
  RelayKey_Type_TYPE_X25519 = 1,
  RelayKey_Type_RelayKey_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RelayKey_Type_RelayKey_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RelayKey_Type_IsValid(int value);
const RelayKey_Type RelayKey_Type_Type_MIN = RelayKey_Type_TYPE_UNKNOWN;
const RelayKey_Type RelayKey_Type_Type_MAX = RelayKey_Type_TYPE_X25519;
const int RelayKey_Type_Type_ARRAYSIZE = RelayKey_Type_Type_MAX + 1;

enum RelayKey_Encryption {
  RelayKey_Encryption_ENCRYPTION_UNKNOWN = 0,
  RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305 = 1,
  RelayKey_Encryption_RelayKey_Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RelayKey_Encryption_RelayKey_Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RelayKey_Encryption_IsValid(int value);
const RelayKey_Encryption RelayKey_Encryption_Encryption_MIN = RelayKey_Encryption_ENCRYPTION_UNKNOWN;
const RelayKey_Encryption RelayKey_Encryption_Encryption_MAX = RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305;
const int RelayKey_Encryption_Encryption_ARRAYSIZE = RelayKey_Encryption_Encryption_MAX + 1;

enum RouterSession {
  ROUTER_SESSION_UNKNOWN = 0,
  ROUTER_SESSION_ADMIN = 1,
  ROUTER_SESSION_CLIENT = 2,
  ROUTER_SESSION_HOST = 4,
  ROUTER_SESSION_RELAY = 8,
  RouterSession_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RouterSession_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RouterSession_IsValid(int value);
const RouterSession RouterSession_MIN = ROUTER_SESSION_UNKNOWN;
const RouterSession RouterSession_MAX = ROUTER_SESSION_RELAY;
const int RouterSession_ARRAYSIZE = RouterSession_MAX + 1;

// ===================================================================

class RelayKey : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayKey) */ {
 public:
  RelayKey();
  virtual ~RelayKey();

  RelayKey(const RelayKey& from);

  inline RelayKey& operator=(const RelayKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const RelayKey& default_instance();

  static inline const RelayKey* internal_default_instance() {
    return reinterpret_cast<const RelayKey*>(
               &_RelayKey_default_instance_);
  }

  void Swap(RelayKey* other);

  // implements Message ----------------------------------------------

  inline RelayKey* New() const PROTOBUF_FINAL { return New(NULL); }

  RelayKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RelayKey& from);
  void MergeFrom(const RelayKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RelayKey_Type Type;
  static const Type TYPE_UNKNOWN =
    RelayKey_Type_TYPE_UNKNOWN;
  static const Type TYPE_X25519 =
    RelayKey_Type_TYPE_X25519;
  static inline bool Type_IsValid(int value) {
    return RelayKey_Type_IsValid(value);
  }
  static const Type Type_MIN =
    RelayKey_Type_Type_MIN;
  static const Type Type_MAX =
    RelayKey_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    RelayKey_Type_Type_ARRAYSIZE;

  typedef RelayKey_Encryption Encryption;
  static const Encryption ENCRYPTION_UNKNOWN =
    RelayKey_Encryption_ENCRYPTION_UNKNOWN;
  static const Encryption ENCRYPTION_CHACHA20_POLY1305 =
    RelayKey_Encryption_ENCRYPTION_CHACHA20_POLY1305;
  static inline bool Encryption_IsValid(int value) {
    return RelayKey_Encryption_IsValid(value);
  }
  static const Encryption Encryption_MIN =
    RelayKey_Encryption_Encryption_MIN;
  static const Encryption Encryption_MAX =
    RelayKey_Encryption_Encryption_MAX;
  static const int Encryption_ARRAYSIZE =
    RelayKey_Encryption_Encryption_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // bytes public_key = 4;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // bytes iv = 5;
  void clear_iv();
  static const int kIvFieldNumber = 5;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // uint32 key_id = 1;
  void clear_key_id();
  static const int kKeyIdFieldNumber = 1;
  ::google::protobuf::uint32 key_id() const;
  void set_key_id(::google::protobuf::uint32 value);

  // .proto.RelayKey.Type type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::proto::RelayKey_Type type() const;
  void set_type(::proto::RelayKey_Type value);

  // .proto.RelayKey.Encryption encryption = 3;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 3;
  ::proto::RelayKey_Encryption encryption() const;
  void set_encryption(::proto::RelayKey_Encryption value);

  // @@protoc_insertion_point(class_scope:proto.RelayKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::uint32 key_id_;
  int type_;
  int encryption_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelayCredentials : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelayCredentials) */ {
 public:
  RelayCredentials();
  virtual ~RelayCredentials();

  RelayCredentials(const RelayCredentials& from);

  inline RelayCredentials& operator=(const RelayCredentials& from) {
    CopyFrom(from);
    return *this;
  }

  static const RelayCredentials& default_instance();

  static inline const RelayCredentials* internal_default_instance() {
    return reinterpret_cast<const RelayCredentials*>(
               &_RelayCredentials_default_instance_);
  }

  void Swap(RelayCredentials* other);

  // implements Message ----------------------------------------------

  inline RelayCredentials* New() const PROTOBUF_FINAL { return New(NULL); }

  RelayCredentials* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RelayCredentials& from);
  void MergeFrom(const RelayCredentials& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelayCredentials* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string host = 1;
  void clear_host();
  static const int kHostFieldNumber = 1;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // bytes secret = 4;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // .proto.RelayKey key = 3;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::proto::RelayKey& key() const;
  ::proto::RelayKey* mutable_key();
  ::proto::RelayKey* release_key();
  void set_allocated_key(::proto::RelayKey* key);

  // uint32 port = 2;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.RelayCredentials)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  ::proto::RelayKey* key_;
  ::google::protobuf::uint32 port_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RelayKey

// uint32 key_id = 1;
inline void RelayKey::clear_key_id() {
  key_id_ = 0u;
}
inline ::google::protobuf::uint32 RelayKey::key_id() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.key_id)
  return key_id_;
}
inline void RelayKey::set_key_id(::google::protobuf::uint32 value) {
  
  key_id_ = value;
  // @@protoc_insertion_point(field_set:proto.RelayKey.key_id)
}

// .proto.RelayKey.Type type = 2;
inline void RelayKey::clear_type() {
  type_ = 0;
}
inline ::proto::RelayKey_Type RelayKey::type() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.type)
  return static_cast< ::proto::RelayKey_Type >(type_);
}
inline void RelayKey::set_type(::proto::RelayKey_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.RelayKey.type)
}

// .proto.RelayKey.Encryption encryption = 3;
inline void RelayKey::clear_encryption() {
  encryption_ = 0;
}
inline ::proto::RelayKey_Encryption RelayKey::encryption() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.encryption)
  return static_cast< ::proto::RelayKey_Encryption >(encryption_);
}
inline void RelayKey::set_encryption(::proto::RelayKey_Encryption value) {
  
  encryption_ = value;
  // @@protoc_insertion_point(field_set:proto.RelayKey.encryption)
}

// bytes public_key = 4;
inline void RelayKey::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RelayKey::public_key() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.public_key)
  return public_key_.GetNoArena();
}
inline void RelayKey::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RelayKey.public_key)
}
#if LANG_CXX11
inline void RelayKey::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RelayKey.public_key)
}
#endif
inline void RelayKey::set_public_key(const char* value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RelayKey.public_key)
}
inline void RelayKey::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RelayKey.public_key)
}
inline ::std::string* RelayKey::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:proto.RelayKey.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayKey::release_public_key() {
  // @@protoc_insertion_point(field_release:proto.RelayKey.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayKey::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:proto.RelayKey.public_key)
}

// bytes iv = 5;
inline void RelayKey::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RelayKey::iv() const {
  // @@protoc_insertion_point(field_get:proto.RelayKey.iv)
  return iv_.GetNoArena();
}
inline void RelayKey::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RelayKey.iv)
}
#if LANG_CXX11
inline void RelayKey::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RelayKey.iv)
}
#endif
inline void RelayKey::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RelayKey.iv)
}
inline void RelayKey::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RelayKey.iv)
}
inline ::std::string* RelayKey::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.RelayKey.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayKey::release_iv() {
  // @@protoc_insertion_point(field_release:proto.RelayKey.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayKey::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.RelayKey.iv)
}

// -------------------------------------------------------------------

// RelayCredentials

// string host = 1;
inline void RelayCredentials::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RelayCredentials::host() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.host)
  return host_.GetNoArena();
}
inline void RelayCredentials::set_host(const ::std::string& value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.host)
}
#if LANG_CXX11
inline void RelayCredentials::set_host(::std::string&& value) {
  
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RelayCredentials.host)
}
#endif
inline void RelayCredentials::set_host(const char* value) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RelayCredentials.host)
}
inline void RelayCredentials::set_host(const char* value, size_t size) {
  
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RelayCredentials.host)
}
inline ::std::string* RelayCredentials::mutable_host() {
  
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayCredentials::release_host() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.host)
  
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayCredentials::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    
  } else {
    
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.host)
}

// uint32 port = 2;
inline void RelayCredentials::clear_port() {
  port_ = 0u;
}
inline ::google::protobuf::uint32 RelayCredentials::port() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.port)
  return port_;
}
inline void RelayCredentials::set_port(::google::protobuf::uint32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.port)
}

// .proto.RelayKey key = 3;
inline bool RelayCredentials::has_key() const {
  return this != internal_default_instance() && key_ != NULL;
}
inline void RelayCredentials::clear_key() {
  if (GetArenaNoVirtual() == NULL && key_ != NULL) delete key_;
  key_ = NULL;
}
inline const ::proto::RelayKey& RelayCredentials::key() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.key)
  return key_ != NULL ? *key_
                         : *::proto::RelayKey::internal_default_instance();
}
inline ::proto::RelayKey* RelayCredentials::mutable_key() {
  
  if (key_ == NULL) {
    key_ = new ::proto::RelayKey;
  }
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.key)
  return key_;
}
inline ::proto::RelayKey* RelayCredentials::release_key() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.key)
  
  ::proto::RelayKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline void RelayCredentials::set_allocated_key(::proto::RelayKey* key) {
  delete key_;
  key_ = key;
  if (key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.key)
}

// bytes secret = 4;
inline void RelayCredentials::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RelayCredentials::secret() const {
  // @@protoc_insertion_point(field_get:proto.RelayCredentials.secret)
  return secret_.GetNoArena();
}
inline void RelayCredentials::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.RelayCredentials.secret)
}
#if LANG_CXX11
inline void RelayCredentials::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.RelayCredentials.secret)
}
#endif
inline void RelayCredentials::set_secret(const char* value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.RelayCredentials.secret)
}
inline void RelayCredentials::set_secret(const void* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.RelayCredentials.secret)
}
inline ::std::string* RelayCredentials::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:proto.RelayCredentials.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RelayCredentials::release_secret() {
  // @@protoc_insertion_point(field_release:proto.RelayCredentials.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RelayCredentials::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:proto.RelayCredentials.secret)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::RelayKey_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::RelayKey_Encryption> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::RouterSession> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_router_5fcommon_2eproto__INCLUDED
