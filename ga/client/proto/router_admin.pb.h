// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_admin.proto

#ifndef PROTOBUF_router_5fadmin_2eproto__INCLUDED
#define PROTOBUF_router_5fadmin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
#include "router_common.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
class AdminToRouter;
class AdminToRouterDefaultTypeInternal;
extern AdminToRouterDefaultTypeInternal _AdminToRouter_default_instance_;
class HostSessionData;
class HostSessionDataDefaultTypeInternal;
extern HostSessionDataDefaultTypeInternal _HostSessionData_default_instance_;
class RelayCredentials;
class RelayCredentialsDefaultTypeInternal;
extern RelayCredentialsDefaultTypeInternal _RelayCredentials_default_instance_;
class RelayKey;
class RelayKeyDefaultTypeInternal;
extern RelayKeyDefaultTypeInternal _RelayKey_default_instance_;
class RelaySessionData;
class RelaySessionDataDefaultTypeInternal;
extern RelaySessionDataDefaultTypeInternal _RelaySessionData_default_instance_;
class RouterToAdmin;
class RouterToAdminDefaultTypeInternal;
extern RouterToAdminDefaultTypeInternal _RouterToAdmin_default_instance_;
class Session;
class SessionDefaultTypeInternal;
extern SessionDefaultTypeInternal _Session_default_instance_;
class SessionList;
class SessionListDefaultTypeInternal;
extern SessionListDefaultTypeInternal _SessionList_default_instance_;
class SessionListRequest;
class SessionListRequestDefaultTypeInternal;
extern SessionListRequestDefaultTypeInternal _SessionListRequest_default_instance_;
class SessionRequest;
class SessionRequestDefaultTypeInternal;
extern SessionRequestDefaultTypeInternal _SessionRequest_default_instance_;
class SessionResult;
class SessionResultDefaultTypeInternal;
extern SessionResultDefaultTypeInternal _SessionResult_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserListRequest;
class UserListRequestDefaultTypeInternal;
extern UserListRequestDefaultTypeInternal _UserListRequest_default_instance_;
class UserRequest;
class UserRequestDefaultTypeInternal;
extern UserRequestDefaultTypeInternal _UserRequest_default_instance_;
class UserResult;
class UserResultDefaultTypeInternal;
extern UserResultDefaultTypeInternal _UserResult_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace proto

namespace proto {

namespace protobuf_router_5fadmin_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_router_5fadmin_2eproto

enum SessionResult_ErrorCode {
  SessionResult_ErrorCode_SUCCESS = 0,
  SessionResult_ErrorCode_INVALID_REQUEST = 1,
  SessionResult_ErrorCode_INTERNAL_ERROR = 2,
  SessionResult_ErrorCode_INVALID_SESSION_ID = 3,
  SessionResult_ErrorCode_SessionResult_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SessionResult_ErrorCode_SessionResult_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SessionResult_ErrorCode_IsValid(int value);
const SessionResult_ErrorCode SessionResult_ErrorCode_ErrorCode_MIN = SessionResult_ErrorCode_SUCCESS;
const SessionResult_ErrorCode SessionResult_ErrorCode_ErrorCode_MAX = SessionResult_ErrorCode_INVALID_SESSION_ID;
const int SessionResult_ErrorCode_ErrorCode_ARRAYSIZE = SessionResult_ErrorCode_ErrorCode_MAX + 1;

enum SessionList_ErrorCode {
  SessionList_ErrorCode_SUCCESS = 0,
  SessionList_ErrorCode_UNKNOWN_ERROR = 1,
  SessionList_ErrorCode_SessionList_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SessionList_ErrorCode_SessionList_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SessionList_ErrorCode_IsValid(int value);
const SessionList_ErrorCode SessionList_ErrorCode_ErrorCode_MIN = SessionList_ErrorCode_SUCCESS;
const SessionList_ErrorCode SessionList_ErrorCode_ErrorCode_MAX = SessionList_ErrorCode_UNKNOWN_ERROR;
const int SessionList_ErrorCode_ErrorCode_ARRAYSIZE = SessionList_ErrorCode_ErrorCode_MAX + 1;

enum UserList_ErrorCode {
  UserList_ErrorCode_SUCCESS = 0,
  UserList_ErrorCode_UNKNOWN_ERROR = 1,
  UserList_ErrorCode_UserList_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserList_ErrorCode_UserList_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserList_ErrorCode_IsValid(int value);
const UserList_ErrorCode UserList_ErrorCode_ErrorCode_MIN = UserList_ErrorCode_SUCCESS;
const UserList_ErrorCode UserList_ErrorCode_ErrorCode_MAX = UserList_ErrorCode_UNKNOWN_ERROR;
const int UserList_ErrorCode_ErrorCode_ARRAYSIZE = UserList_ErrorCode_ErrorCode_MAX + 1;

enum UserResult_ErrorCode {
  UserResult_ErrorCode_SUCCESS = 0,
  UserResult_ErrorCode_INTERNAL_ERROR = 1,
  UserResult_ErrorCode_INVALID_DATA = 2,
  UserResult_ErrorCode_ALREADY_EXISTS = 3,
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserResult_ErrorCode_UserResult_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserResult_ErrorCode_IsValid(int value);
const UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MIN = UserResult_ErrorCode_SUCCESS;
const UserResult_ErrorCode UserResult_ErrorCode_ErrorCode_MAX = UserResult_ErrorCode_ALREADY_EXISTS;
const int UserResult_ErrorCode_ErrorCode_ARRAYSIZE = UserResult_ErrorCode_ErrorCode_MAX + 1;

enum SessionRequestType {
  SESSION_REQUEST_UNKNOWN = 0,
  SESSION_REQUEST_DISCONNECT = 1,
  SessionRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SessionRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SessionRequestType_IsValid(int value);
const SessionRequestType SessionRequestType_MIN = SESSION_REQUEST_UNKNOWN;
const SessionRequestType SessionRequestType_MAX = SESSION_REQUEST_DISCONNECT;
const int SessionRequestType_ARRAYSIZE = SessionRequestType_MAX + 1;

enum UserRequestType {
  USER_REQUEST_UNKNOWN = 0,
  USER_REQUEST_ADD = 1,
  USER_REQUEST_MODIFY = 2,
  USER_REQUEST_DELETE = 3,
  UserRequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserRequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserRequestType_IsValid(int value);
const UserRequestType UserRequestType_MIN = USER_REQUEST_UNKNOWN;
const UserRequestType UserRequestType_MAX = USER_REQUEST_DELETE;
const int UserRequestType_ARRAYSIZE = UserRequestType_MAX + 1;

// ===================================================================

class Session : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.Session) */ {
 public:
  Session();
  virtual ~Session();

  Session(const Session& from);

  inline Session& operator=(const Session& from) {
    CopyFrom(from);
    return *this;
  }

  static const Session& default_instance();

  static inline const Session* internal_default_instance() {
    return reinterpret_cast<const Session*>(
               &_Session_default_instance_);
  }

  void Swap(Session* other);

  // implements Message ----------------------------------------------

  inline Session* New() const PROTOBUF_FINAL { return New(NULL); }

  Session* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Session& from);
  void MergeFrom(const Session& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Session* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes session_data = 3;
  void clear_session_data();
  static const int kSessionDataFieldNumber = 3;
  const ::std::string& session_data() const;
  void set_session_data(const ::std::string& value);
  #if LANG_CXX11
  void set_session_data(::std::string&& value);
  #endif
  void set_session_data(const char* value);
  void set_session_data(const void* value, size_t size);
  ::std::string* mutable_session_data();
  ::std::string* release_session_data();
  void set_allocated_session_data(::std::string* session_data);

  // string ip_address = 5;
  void clear_ip_address();
  static const int kIpAddressFieldNumber = 5;
  const ::std::string& ip_address() const;
  void set_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_address(::std::string&& value);
  #endif
  void set_ip_address(const char* value);
  void set_ip_address(const char* value, size_t size);
  ::std::string* mutable_ip_address();
  ::std::string* release_ip_address();
  void set_allocated_ip_address(::std::string* ip_address);

  // string os_name = 7;
  void clear_os_name();
  static const int kOsNameFieldNumber = 7;
  const ::std::string& os_name() const;
  void set_os_name(const ::std::string& value);
  #if LANG_CXX11
  void set_os_name(::std::string&& value);
  #endif
  void set_os_name(const char* value);
  void set_os_name(const char* value, size_t size);
  ::std::string* mutable_os_name();
  ::std::string* release_os_name();
  void set_allocated_os_name(::std::string* os_name);

  // string computer_name = 8;
  void clear_computer_name();
  static const int kComputerNameFieldNumber = 8;
  const ::std::string& computer_name() const;
  void set_computer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_computer_name(::std::string&& value);
  #endif
  void set_computer_name(const char* value);
  void set_computer_name(const char* value, size_t size);
  ::std::string* mutable_computer_name();
  ::std::string* release_computer_name();
  void set_allocated_computer_name(::std::string* computer_name);

  // .proto.Version version = 6;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  const ::proto::Version& version() const;
  ::proto::Version* mutable_version();
  ::proto::Version* release_version();
  void set_allocated_version(::proto::Version* version);

  // int64 session_id = 1;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 1;
  ::google::protobuf::int64 session_id() const;
  void set_session_id(::google::protobuf::int64 value);

  // fixed64 timepoint = 4;
  void clear_timepoint();
  static const int kTimepointFieldNumber = 4;
  ::google::protobuf::uint64 timepoint() const;
  void set_timepoint(::google::protobuf::uint64 value);

  // .proto.RouterSession session_type = 2;
  void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  ::proto::RouterSession session_type() const;
  void set_session_type(::proto::RouterSession value);

  // @@protoc_insertion_point(class_scope:proto.Session)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_data_;
  ::google::protobuf::internal::ArenaStringPtr ip_address_;
  ::google::protobuf::internal::ArenaStringPtr os_name_;
  ::google::protobuf::internal::ArenaStringPtr computer_name_;
  ::proto::Version* version_;
  ::google::protobuf::int64 session_id_;
  ::google::protobuf::uint64 timepoint_;
  int session_type_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionRequest) */ {
 public:
  SessionRequest();
  virtual ~SessionRequest();

  SessionRequest(const SessionRequest& from);

  inline SessionRequest& operator=(const SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionRequest& default_instance();

  static inline const SessionRequest* internal_default_instance() {
    return reinterpret_cast<const SessionRequest*>(
               &_SessionRequest_default_instance_);
  }

  void Swap(SessionRequest* other);

  // implements Message ----------------------------------------------

  inline SessionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionRequest& from);
  void MergeFrom(const SessionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 session_id = 2;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 2;
  ::google::protobuf::int64 session_id() const;
  void set_session_id(::google::protobuf::int64 value);

  // .proto.SessionRequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::SessionRequestType type() const;
  void set_type(::proto::SessionRequestType value);

  // @@protoc_insertion_point(class_scope:proto.SessionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 session_id_;
  int type_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionResult : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionResult) */ {
 public:
  SessionResult();
  virtual ~SessionResult();

  SessionResult(const SessionResult& from);

  inline SessionResult& operator=(const SessionResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionResult& default_instance();

  static inline const SessionResult* internal_default_instance() {
    return reinterpret_cast<const SessionResult*>(
               &_SessionResult_default_instance_);
  }

  void Swap(SessionResult* other);

  // implements Message ----------------------------------------------

  inline SessionResult* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionResult& from);
  void MergeFrom(const SessionResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SessionResult_ErrorCode ErrorCode;
  static const ErrorCode SUCCESS =
    SessionResult_ErrorCode_SUCCESS;
  static const ErrorCode INVALID_REQUEST =
    SessionResult_ErrorCode_INVALID_REQUEST;
  static const ErrorCode INTERNAL_ERROR =
    SessionResult_ErrorCode_INTERNAL_ERROR;
  static const ErrorCode INVALID_SESSION_ID =
    SessionResult_ErrorCode_INVALID_SESSION_ID;
  static inline bool ErrorCode_IsValid(int value) {
    return SessionResult_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    SessionResult_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    SessionResult_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    SessionResult_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.SessionRequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::SessionRequestType type() const;
  void set_type(::proto::SessionRequestType value);

  // .proto.SessionResult.ErrorCode error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::proto::SessionResult_ErrorCode error_code() const;
  void set_error_code(::proto::SessionResult_ErrorCode value);

  // @@protoc_insertion_point(class_scope:proto.SessionResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int type_;
  int error_code_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionListRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionListRequest) */ {
 public:
  SessionListRequest();
  virtual ~SessionListRequest();

  SessionListRequest(const SessionListRequest& from);

  inline SessionListRequest& operator=(const SessionListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionListRequest& default_instance();

  static inline const SessionListRequest* internal_default_instance() {
    return reinterpret_cast<const SessionListRequest*>(
               &_SessionListRequest_default_instance_);
  }

  void Swap(SessionListRequest* other);

  // implements Message ----------------------------------------------

  inline SessionListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionListRequest& from);
  void MergeFrom(const SessionListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 dummy = 1;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  ::google::protobuf::int64 dummy() const;
  void set_dummy(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:proto.SessionListRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::int64 dummy_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionList) */ {
 public:
  SessionList();
  virtual ~SessionList();

  SessionList(const SessionList& from);

  inline SessionList& operator=(const SessionList& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionList& default_instance();

  static inline const SessionList* internal_default_instance() {
    return reinterpret_cast<const SessionList*>(
               &_SessionList_default_instance_);
  }

  void Swap(SessionList* other);

  // implements Message ----------------------------------------------

  inline SessionList* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionList& from);
  void MergeFrom(const SessionList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SessionList_ErrorCode ErrorCode;
  static const ErrorCode SUCCESS =
    SessionList_ErrorCode_SUCCESS;
  static const ErrorCode UNKNOWN_ERROR =
    SessionList_ErrorCode_UNKNOWN_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return SessionList_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    SessionList_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    SessionList_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    SessionList_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .proto.Session session = 2;
  int session_size() const;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  const ::proto::Session& session(int index) const;
  ::proto::Session* mutable_session(int index);
  ::proto::Session* add_session();
  ::google::protobuf::RepeatedPtrField< ::proto::Session >*
      mutable_session();
  const ::google::protobuf::RepeatedPtrField< ::proto::Session >&
      session() const;

  // .proto.SessionList.ErrorCode error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::proto::SessionList_ErrorCode error_code() const;
  void set_error_code(::proto::SessionList_ErrorCode value);

  // @@protoc_insertion_point(class_scope:proto.SessionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::Session > session_;
  int error_code_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HostSessionData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostSessionData) */ {
 public:
  HostSessionData();
  virtual ~HostSessionData();

  HostSessionData(const HostSessionData& from);

  inline HostSessionData& operator=(const HostSessionData& from) {
    CopyFrom(from);
    return *this;
  }

  static const HostSessionData& default_instance();

  static inline const HostSessionData* internal_default_instance() {
    return reinterpret_cast<const HostSessionData*>(
               &_HostSessionData_default_instance_);
  }

  void Swap(HostSessionData* other);

  // implements Message ----------------------------------------------

  inline HostSessionData* New() const PROTOBUF_FINAL { return New(NULL); }

  HostSessionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HostSessionData& from);
  void MergeFrom(const HostSessionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostSessionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated fixed64 host_id = 1;
  int host_id_size() const;
  void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  ::google::protobuf::uint64 host_id(int index) const;
  void set_host_id(int index, ::google::protobuf::uint64 value);
  void add_host_id(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      host_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_host_id();

  // @@protoc_insertion_point(class_scope:proto.HostSessionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > host_id_;
  mutable int _host_id_cached_byte_size_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelaySessionData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.RelaySessionData) */ {
 public:
  RelaySessionData();
  virtual ~RelaySessionData();

  RelaySessionData(const RelaySessionData& from);

  inline RelaySessionData& operator=(const RelaySessionData& from) {
    CopyFrom(from);
    return *this;
  }

  static const RelaySessionData& default_instance();

  static inline const RelaySessionData* internal_default_instance() {
    return reinterpret_cast<const RelaySessionData*>(
               &_RelaySessionData_default_instance_);
  }

  void Swap(RelaySessionData* other);

  // implements Message ----------------------------------------------

  inline RelaySessionData* New() const PROTOBUF_FINAL { return New(NULL); }

  RelaySessionData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RelaySessionData& from);
  void MergeFrom(const RelaySessionData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RelaySessionData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 pool_size = 1;
  void clear_pool_size();
  static const int kPoolSizeFieldNumber = 1;
  ::google::protobuf::uint64 pool_size() const;
  void set_pool_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.RelaySessionData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 pool_size_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }

  static const User& default_instance();

  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }

  void Swap(User* other);

  // implements Message ----------------------------------------------

  inline User* New() const PROTOBUF_FINAL { return New(NULL); }

  User* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string group = 3;
  void clear_group();
  static const int kGroupFieldNumber = 3;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // bytes salt = 4;
  void clear_salt();
  static const int kSaltFieldNumber = 4;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // bytes verifier = 5;
  void clear_verifier();
  static const int kVerifierFieldNumber = 5;
  const ::std::string& verifier() const;
  void set_verifier(const ::std::string& value);
  #if LANG_CXX11
  void set_verifier(::std::string&& value);
  #endif
  void set_verifier(const char* value);
  void set_verifier(const void* value, size_t size);
  ::std::string* mutable_verifier();
  ::std::string* release_verifier();
  void set_allocated_verifier(::std::string* verifier);

  // int64 entry_id = 1;
  void clear_entry_id();
  static const int kEntryIdFieldNumber = 1;
  ::google::protobuf::int64 entry_id() const;
  void set_entry_id(::google::protobuf::int64 value);

  // uint32 sessions = 6;
  void clear_sessions();
  static const int kSessionsFieldNumber = 6;
  ::google::protobuf::uint32 sessions() const;
  void set_sessions(::google::protobuf::uint32 value);

  // uint32 flags = 7;
  void clear_flags();
  static const int kFlagsFieldNumber = 7;
  ::google::protobuf::uint32 flags() const;
  void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.User)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr verifier_;
  ::google::protobuf::int64 entry_id_;
  ::google::protobuf::uint32 sessions_;
  ::google::protobuf::uint32 flags_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserListRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserListRequest) */ {
 public:
  UserListRequest();
  virtual ~UserListRequest();

  UserListRequest(const UserListRequest& from);

  inline UserListRequest& operator=(const UserListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserListRequest& default_instance();

  static inline const UserListRequest* internal_default_instance() {
    return reinterpret_cast<const UserListRequest*>(
               &_UserListRequest_default_instance_);
  }

  void Swap(UserListRequest* other);

  // implements Message ----------------------------------------------

  inline UserListRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UserListRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserListRequest& from);
  void MergeFrom(const UserListRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 dummy = 1;
  void clear_dummy();
  static const int kDummyFieldNumber = 1;
  ::google::protobuf::uint32 dummy() const;
  void set_dummy(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.UserListRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint32 dummy_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserList : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserList) */ {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserList& default_instance();

  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }

  void Swap(UserList* other);

  // implements Message ----------------------------------------------

  inline UserList* New() const PROTOBUF_FINAL { return New(NULL); }

  UserList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserList_ErrorCode ErrorCode;
  static const ErrorCode SUCCESS =
    UserList_ErrorCode_SUCCESS;
  static const ErrorCode UNKNOWN_ERROR =
    UserList_ErrorCode_UNKNOWN_ERROR;
  static inline bool ErrorCode_IsValid(int value) {
    return UserList_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UserList_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UserList_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    UserList_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .proto.User user = 2;
  int user_size() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::proto::User& user(int index) const;
  ::proto::User* mutable_user(int index);
  ::proto::User* add_user();
  ::google::protobuf::RepeatedPtrField< ::proto::User >*
      mutable_user();
  const ::google::protobuf::RepeatedPtrField< ::proto::User >&
      user() const;

  // .proto.UserList.ErrorCode error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::proto::UserList_ErrorCode error_code() const;
  void set_error_code(::proto::UserList_ErrorCode value);

  // @@protoc_insertion_point(class_scope:proto.UserList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::proto::User > user_;
  int error_code_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserRequest) */ {
 public:
  UserRequest();
  virtual ~UserRequest();

  UserRequest(const UserRequest& from);

  inline UserRequest& operator=(const UserRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserRequest& default_instance();

  static inline const UserRequest* internal_default_instance() {
    return reinterpret_cast<const UserRequest*>(
               &_UserRequest_default_instance_);
  }

  void Swap(UserRequest* other);

  // implements Message ----------------------------------------------

  inline UserRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  UserRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserRequest& from);
  void MergeFrom(const UserRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.User user = 2;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 2;
  const ::proto::User& user() const;
  ::proto::User* mutable_user();
  ::proto::User* release_user();
  void set_allocated_user(::proto::User* user);

  // .proto.UserRequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);

  // @@protoc_insertion_point(class_scope:proto.UserRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::User* user_;
  int type_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserResult : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.UserResult) */ {
 public:
  UserResult();
  virtual ~UserResult();

  UserResult(const UserResult& from);

  inline UserResult& operator=(const UserResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const UserResult& default_instance();

  static inline const UserResult* internal_default_instance() {
    return reinterpret_cast<const UserResult*>(
               &_UserResult_default_instance_);
  }

  void Swap(UserResult* other);

  // implements Message ----------------------------------------------

  inline UserResult* New() const PROTOBUF_FINAL { return New(NULL); }

  UserResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const UserResult& from);
  void MergeFrom(const UserResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UserResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef UserResult_ErrorCode ErrorCode;
  static const ErrorCode SUCCESS =
    UserResult_ErrorCode_SUCCESS;
  static const ErrorCode INTERNAL_ERROR =
    UserResult_ErrorCode_INTERNAL_ERROR;
  static const ErrorCode INVALID_DATA =
    UserResult_ErrorCode_INVALID_DATA;
  static const ErrorCode ALREADY_EXISTS =
    UserResult_ErrorCode_ALREADY_EXISTS;
  static inline bool ErrorCode_IsValid(int value) {
    return UserResult_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UserResult_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UserResult_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    UserResult_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.UserRequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::UserRequestType type() const;
  void set_type(::proto::UserRequestType value);

  // .proto.UserResult.ErrorCode error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::proto::UserResult_ErrorCode error_code() const;
  void set_error_code(::proto::UserResult_ErrorCode value);

  // @@protoc_insertion_point(class_scope:proto.UserResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  int type_;
  int error_code_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouterToAdmin : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.RouterToAdmin) */ {
 public:
  RouterToAdmin();
  virtual ~RouterToAdmin();

  RouterToAdmin(const RouterToAdmin& from);

  inline RouterToAdmin& operator=(const RouterToAdmin& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouterToAdmin& default_instance();

  static inline const RouterToAdmin* internal_default_instance() {
    return reinterpret_cast<const RouterToAdmin*>(
               &_RouterToAdmin_default_instance_);
  }

  void Swap(RouterToAdmin* other);

  // implements Message ----------------------------------------------

  inline RouterToAdmin* New() const PROTOBUF_FINAL { return New(NULL); }

  RouterToAdmin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RouterToAdmin& from);
  void MergeFrom(const RouterToAdmin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouterToAdmin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.SessionList session_list = 1;
  bool has_session_list() const;
  void clear_session_list();
  static const int kSessionListFieldNumber = 1;
  const ::proto::SessionList& session_list() const;
  ::proto::SessionList* mutable_session_list();
  ::proto::SessionList* release_session_list();
  void set_allocated_session_list(::proto::SessionList* session_list);

  // .proto.SessionResult session_result = 2;
  bool has_session_result() const;
  void clear_session_result();
  static const int kSessionResultFieldNumber = 2;
  const ::proto::SessionResult& session_result() const;
  ::proto::SessionResult* mutable_session_result();
  ::proto::SessionResult* release_session_result();
  void set_allocated_session_result(::proto::SessionResult* session_result);

  // .proto.UserList user_list = 3;
  bool has_user_list() const;
  void clear_user_list();
  static const int kUserListFieldNumber = 3;
  const ::proto::UserList& user_list() const;
  ::proto::UserList* mutable_user_list();
  ::proto::UserList* release_user_list();
  void set_allocated_user_list(::proto::UserList* user_list);

  // .proto.UserResult user_result = 4;
  bool has_user_result() const;
  void clear_user_result();
  static const int kUserResultFieldNumber = 4;
  const ::proto::UserResult& user_result() const;
  ::proto::UserResult* mutable_user_result();
  ::proto::UserResult* release_user_result();
  void set_allocated_user_result(::proto::UserResult* user_result);

  // @@protoc_insertion_point(class_scope:proto.RouterToAdmin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::SessionList* session_list_;
  ::proto::SessionResult* session_result_;
  ::proto::UserList* user_list_;
  ::proto::UserResult* user_result_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AdminToRouter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.AdminToRouter) */ {
 public:
  AdminToRouter();
  virtual ~AdminToRouter();

  AdminToRouter(const AdminToRouter& from);

  inline AdminToRouter& operator=(const AdminToRouter& from) {
    CopyFrom(from);
    return *this;
  }

  static const AdminToRouter& default_instance();

  static inline const AdminToRouter* internal_default_instance() {
    return reinterpret_cast<const AdminToRouter*>(
               &_AdminToRouter_default_instance_);
  }

  void Swap(AdminToRouter* other);

  // implements Message ----------------------------------------------

  inline AdminToRouter* New() const PROTOBUF_FINAL { return New(NULL); }

  AdminToRouter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AdminToRouter& from);
  void MergeFrom(const AdminToRouter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdminToRouter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.SessionListRequest session_list_request = 1;
  bool has_session_list_request() const;
  void clear_session_list_request();
  static const int kSessionListRequestFieldNumber = 1;
  const ::proto::SessionListRequest& session_list_request() const;
  ::proto::SessionListRequest* mutable_session_list_request();
  ::proto::SessionListRequest* release_session_list_request();
  void set_allocated_session_list_request(::proto::SessionListRequest* session_list_request);

  // .proto.SessionRequest session_request = 2;
  bool has_session_request() const;
  void clear_session_request();
  static const int kSessionRequestFieldNumber = 2;
  const ::proto::SessionRequest& session_request() const;
  ::proto::SessionRequest* mutable_session_request();
  ::proto::SessionRequest* release_session_request();
  void set_allocated_session_request(::proto::SessionRequest* session_request);

  // .proto.UserListRequest user_list_request = 3;
  bool has_user_list_request() const;
  void clear_user_list_request();
  static const int kUserListRequestFieldNumber = 3;
  const ::proto::UserListRequest& user_list_request() const;
  ::proto::UserListRequest* mutable_user_list_request();
  ::proto::UserListRequest* release_user_list_request();
  void set_allocated_user_list_request(::proto::UserListRequest* user_list_request);

  // .proto.UserRequest user_request = 4;
  bool has_user_request() const;
  void clear_user_request();
  static const int kUserRequestFieldNumber = 4;
  const ::proto::UserRequest& user_request() const;
  ::proto::UserRequest* mutable_user_request();
  ::proto::UserRequest* release_user_request();
  void set_allocated_user_request(::proto::UserRequest* user_request);

  // @@protoc_insertion_point(class_scope:proto.AdminToRouter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::SessionListRequest* session_list_request_;
  ::proto::SessionRequest* session_request_;
  ::proto::UserListRequest* user_list_request_;
  ::proto::UserRequest* user_request_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fadmin_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Session

// int64 session_id = 1;
inline void Session::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Session::session_id() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_id)
  return session_id_;
}
inline void Session::set_session_id(::google::protobuf::int64 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:proto.Session.session_id)
}

// .proto.RouterSession session_type = 2;
inline void Session::clear_session_type() {
  session_type_ = 0;
}
inline ::proto::RouterSession Session::session_type() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_type)
  return static_cast< ::proto::RouterSession >(session_type_);
}
inline void Session::set_session_type(::proto::RouterSession value) {
  
  session_type_ = value;
  // @@protoc_insertion_point(field_set:proto.Session.session_type)
}

// bytes session_data = 3;
inline void Session::clear_session_data() {
  session_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::session_data() const {
  // @@protoc_insertion_point(field_get:proto.Session.session_data)
  return session_data_.GetNoArena();
}
inline void Session::set_session_data(const ::std::string& value) {
  
  session_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Session.session_data)
}
#if LANG_CXX11
inline void Session::set_session_data(::std::string&& value) {
  
  session_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Session.session_data)
}
#endif
inline void Session::set_session_data(const char* value) {
  
  session_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Session.session_data)
}
inline void Session::set_session_data(const void* value, size_t size) {
  
  session_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Session.session_data)
}
inline ::std::string* Session::mutable_session_data() {
  
  // @@protoc_insertion_point(field_mutable:proto.Session.session_data)
  return session_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_session_data() {
  // @@protoc_insertion_point(field_release:proto.Session.session_data)
  
  return session_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_session_data(::std::string* session_data) {
  if (session_data != NULL) {
    
  } else {
    
  }
  session_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_data);
  // @@protoc_insertion_point(field_set_allocated:proto.Session.session_data)
}

// fixed64 timepoint = 4;
inline void Session::clear_timepoint() {
  timepoint_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Session::timepoint() const {
  // @@protoc_insertion_point(field_get:proto.Session.timepoint)
  return timepoint_;
}
inline void Session::set_timepoint(::google::protobuf::uint64 value) {
  
  timepoint_ = value;
  // @@protoc_insertion_point(field_set:proto.Session.timepoint)
}

// string ip_address = 5;
inline void Session::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::ip_address() const {
  // @@protoc_insertion_point(field_get:proto.Session.ip_address)
  return ip_address_.GetNoArena();
}
inline void Session::set_ip_address(const ::std::string& value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Session.ip_address)
}
#if LANG_CXX11
inline void Session::set_ip_address(::std::string&& value) {
  
  ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Session.ip_address)
}
#endif
inline void Session::set_ip_address(const char* value) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Session.ip_address)
}
inline void Session::set_ip_address(const char* value, size_t size) {
  
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Session.ip_address)
}
inline ::std::string* Session::mutable_ip_address() {
  
  // @@protoc_insertion_point(field_mutable:proto.Session.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_ip_address() {
  // @@protoc_insertion_point(field_release:proto.Session.ip_address)
  
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    
  } else {
    
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:proto.Session.ip_address)
}

// .proto.Version version = 6;
inline bool Session::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void Session::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) delete version_;
  version_ = NULL;
}
inline const ::proto::Version& Session::version() const {
  // @@protoc_insertion_point(field_get:proto.Session.version)
  return version_ != NULL ? *version_
                         : *::proto::Version::internal_default_instance();
}
inline ::proto::Version* Session::mutable_version() {
  
  if (version_ == NULL) {
    version_ = new ::proto::Version;
  }
  // @@protoc_insertion_point(field_mutable:proto.Session.version)
  return version_;
}
inline ::proto::Version* Session::release_version() {
  // @@protoc_insertion_point(field_release:proto.Session.version)
  
  ::proto::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void Session::set_allocated_version(::proto::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.Session.version)
}

// string os_name = 7;
inline void Session::clear_os_name() {
  os_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::os_name() const {
  // @@protoc_insertion_point(field_get:proto.Session.os_name)
  return os_name_.GetNoArena();
}
inline void Session::set_os_name(const ::std::string& value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Session.os_name)
}
#if LANG_CXX11
inline void Session::set_os_name(::std::string&& value) {
  
  os_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Session.os_name)
}
#endif
inline void Session::set_os_name(const char* value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Session.os_name)
}
inline void Session::set_os_name(const char* value, size_t size) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Session.os_name)
}
inline ::std::string* Session::mutable_os_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Session.os_name)
  return os_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.Session.os_name)
  
  return os_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_os_name(::std::string* os_name) {
  if (os_name != NULL) {
    
  } else {
    
  }
  os_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_name);
  // @@protoc_insertion_point(field_set_allocated:proto.Session.os_name)
}

// string computer_name = 8;
inline void Session::clear_computer_name() {
  computer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Session::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.Session.computer_name)
  return computer_name_.GetNoArena();
}
inline void Session::set_computer_name(const ::std::string& value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.Session.computer_name)
}
#if LANG_CXX11
inline void Session::set_computer_name(::std::string&& value) {
  
  computer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.Session.computer_name)
}
#endif
inline void Session::set_computer_name(const char* value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.Session.computer_name)
}
inline void Session::set_computer_name(const char* value, size_t size) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.Session.computer_name)
}
inline ::std::string* Session::mutable_computer_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.Session.computer_name)
  return computer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Session::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.Session.computer_name)
  
  return computer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Session::set_allocated_computer_name(::std::string* computer_name) {
  if (computer_name != NULL) {
    
  } else {
    
  }
  computer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), computer_name);
  // @@protoc_insertion_point(field_set_allocated:proto.Session.computer_name)
}

// -------------------------------------------------------------------

// SessionRequest

// .proto.SessionRequestType type = 1;
inline void SessionRequest::clear_type() {
  type_ = 0;
}
inline ::proto::SessionRequestType SessionRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.SessionRequest.type)
  return static_cast< ::proto::SessionRequestType >(type_);
}
inline void SessionRequest::set_type(::proto::SessionRequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionRequest.type)
}

// int64 session_id = 2;
inline void SessionRequest::clear_session_id() {
  session_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionRequest::session_id() const {
  // @@protoc_insertion_point(field_get:proto.SessionRequest.session_id)
  return session_id_;
}
inline void SessionRequest::set_session_id(::google::protobuf::int64 value) {
  
  session_id_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionRequest.session_id)
}

// -------------------------------------------------------------------

// SessionResult

// .proto.SessionRequestType type = 1;
inline void SessionResult::clear_type() {
  type_ = 0;
}
inline ::proto::SessionRequestType SessionResult::type() const {
  // @@protoc_insertion_point(field_get:proto.SessionResult.type)
  return static_cast< ::proto::SessionRequestType >(type_);
}
inline void SessionResult::set_type(::proto::SessionRequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionResult.type)
}

// .proto.SessionResult.ErrorCode error_code = 2;
inline void SessionResult::clear_error_code() {
  error_code_ = 0;
}
inline ::proto::SessionResult_ErrorCode SessionResult::error_code() const {
  // @@protoc_insertion_point(field_get:proto.SessionResult.error_code)
  return static_cast< ::proto::SessionResult_ErrorCode >(error_code_);
}
inline void SessionResult::set_error_code(::proto::SessionResult_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionResult.error_code)
}

// -------------------------------------------------------------------

// SessionListRequest

// int64 dummy = 1;
inline void SessionListRequest::clear_dummy() {
  dummy_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SessionListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.SessionListRequest.dummy)
  return dummy_;
}
inline void SessionListRequest::set_dummy(::google::protobuf::int64 value) {
  
  dummy_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionListRequest.dummy)
}

// -------------------------------------------------------------------

// SessionList

// .proto.SessionList.ErrorCode error_code = 1;
inline void SessionList::clear_error_code() {
  error_code_ = 0;
}
inline ::proto::SessionList_ErrorCode SessionList::error_code() const {
  // @@protoc_insertion_point(field_get:proto.SessionList.error_code)
  return static_cast< ::proto::SessionList_ErrorCode >(error_code_);
}
inline void SessionList::set_error_code(::proto::SessionList_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionList.error_code)
}

// repeated .proto.Session session = 2;
inline int SessionList::session_size() const {
  return session_.size();
}
inline void SessionList::clear_session() {
  session_.Clear();
}
inline const ::proto::Session& SessionList::session(int index) const {
  // @@protoc_insertion_point(field_get:proto.SessionList.session)
  return session_.Get(index);
}
inline ::proto::Session* SessionList::mutable_session(int index) {
  // @@protoc_insertion_point(field_mutable:proto.SessionList.session)
  return session_.Mutable(index);
}
inline ::proto::Session* SessionList::add_session() {
  // @@protoc_insertion_point(field_add:proto.SessionList.session)
  return session_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::Session >*
SessionList::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:proto.SessionList.session)
  return &session_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::Session >&
SessionList::session() const {
  // @@protoc_insertion_point(field_list:proto.SessionList.session)
  return session_;
}

// -------------------------------------------------------------------

// HostSessionData

// repeated fixed64 host_id = 1;
inline int HostSessionData::host_id_size() const {
  return host_id_.size();
}
inline void HostSessionData::clear_host_id() {
  host_id_.Clear();
}
inline ::google::protobuf::uint64 HostSessionData::host_id(int index) const {
  // @@protoc_insertion_point(field_get:proto.HostSessionData.host_id)
  return host_id_.Get(index);
}
inline void HostSessionData::set_host_id(int index, ::google::protobuf::uint64 value) {
  host_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:proto.HostSessionData.host_id)
}
inline void HostSessionData::add_host_id(::google::protobuf::uint64 value) {
  host_id_.Add(value);
  // @@protoc_insertion_point(field_add:proto.HostSessionData.host_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
HostSessionData::host_id() const {
  // @@protoc_insertion_point(field_list:proto.HostSessionData.host_id)
  return host_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
HostSessionData::mutable_host_id() {
  // @@protoc_insertion_point(field_mutable_list:proto.HostSessionData.host_id)
  return &host_id_;
}

// -------------------------------------------------------------------

// RelaySessionData

// uint64 pool_size = 1;
inline void RelaySessionData::clear_pool_size() {
  pool_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RelaySessionData::pool_size() const {
  // @@protoc_insertion_point(field_get:proto.RelaySessionData.pool_size)
  return pool_size_;
}
inline void RelaySessionData::set_pool_size(::google::protobuf::uint64 value) {
  
  pool_size_ = value;
  // @@protoc_insertion_point(field_set:proto.RelaySessionData.pool_size)
}

// -------------------------------------------------------------------

// User

// int64 entry_id = 1;
inline void User::clear_entry_id() {
  entry_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 User::entry_id() const {
  // @@protoc_insertion_point(field_get:proto.User.entry_id)
  return entry_id_;
}
inline void User::set_entry_id(::google::protobuf::int64 value) {
  
  entry_id_ = value;
  // @@protoc_insertion_point(field_set:proto.User.entry_id)
}

// string name = 2;
inline void User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:proto.User.name)
  return name_.GetNoArena();
}
inline void User::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.User.name)
}
#if LANG_CXX11
inline void User::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.User.name)
}
#endif
inline void User::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.User.name)
}
inline ::std::string* User::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:proto.User.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:proto.User.name)
}

// string group = 3;
inline void User::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::group() const {
  // @@protoc_insertion_point(field_get:proto.User.group)
  return group_.GetNoArena();
}
inline void User::set_group(const ::std::string& value) {
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.User.group)
}
#if LANG_CXX11
inline void User::set_group(::std::string&& value) {
  
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.User.group)
}
#endif
inline void User::set_group(const char* value) {
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.User.group)
}
inline void User::set_group(const char* value, size_t size) {
  
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.User.group)
}
inline ::std::string* User::mutable_group() {
  
  // @@protoc_insertion_point(field_mutable:proto.User.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_group() {
  // @@protoc_insertion_point(field_release:proto.User.group)
  
  return group_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_group(::std::string* group) {
  if (group != NULL) {
    
  } else {
    
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:proto.User.group)
}

// bytes salt = 4;
inline void User::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::salt() const {
  // @@protoc_insertion_point(field_get:proto.User.salt)
  return salt_.GetNoArena();
}
inline void User::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.User.salt)
}
#if LANG_CXX11
inline void User::set_salt(::std::string&& value) {
  
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.User.salt)
}
#endif
inline void User::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.User.salt)
}
inline void User::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.User.salt)
}
inline ::std::string* User::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:proto.User.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_salt() {
  // @@protoc_insertion_point(field_release:proto.User.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:proto.User.salt)
}

// bytes verifier = 5;
inline void User::clear_verifier() {
  verifier_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::verifier() const {
  // @@protoc_insertion_point(field_get:proto.User.verifier)
  return verifier_.GetNoArena();
}
inline void User::set_verifier(const ::std::string& value) {
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.User.verifier)
}
#if LANG_CXX11
inline void User::set_verifier(::std::string&& value) {
  
  verifier_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.User.verifier)
}
#endif
inline void User::set_verifier(const char* value) {
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.User.verifier)
}
inline void User::set_verifier(const void* value, size_t size) {
  
  verifier_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.User.verifier)
}
inline ::std::string* User::mutable_verifier() {
  
  // @@protoc_insertion_point(field_mutable:proto.User.verifier)
  return verifier_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_verifier() {
  // @@protoc_insertion_point(field_release:proto.User.verifier)
  
  return verifier_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_verifier(::std::string* verifier) {
  if (verifier != NULL) {
    
  } else {
    
  }
  verifier_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), verifier);
  // @@protoc_insertion_point(field_set_allocated:proto.User.verifier)
}

// uint32 sessions = 6;
inline void User::clear_sessions() {
  sessions_ = 0u;
}
inline ::google::protobuf::uint32 User::sessions() const {
  // @@protoc_insertion_point(field_get:proto.User.sessions)
  return sessions_;
}
inline void User::set_sessions(::google::protobuf::uint32 value) {
  
  sessions_ = value;
  // @@protoc_insertion_point(field_set:proto.User.sessions)
}

// uint32 flags = 7;
inline void User::clear_flags() {
  flags_ = 0u;
}
inline ::google::protobuf::uint32 User::flags() const {
  // @@protoc_insertion_point(field_get:proto.User.flags)
  return flags_;
}
inline void User::set_flags(::google::protobuf::uint32 value) {
  
  flags_ = value;
  // @@protoc_insertion_point(field_set:proto.User.flags)
}

// -------------------------------------------------------------------

// UserListRequest

// uint32 dummy = 1;
inline void UserListRequest::clear_dummy() {
  dummy_ = 0u;
}
inline ::google::protobuf::uint32 UserListRequest::dummy() const {
  // @@protoc_insertion_point(field_get:proto.UserListRequest.dummy)
  return dummy_;
}
inline void UserListRequest::set_dummy(::google::protobuf::uint32 value) {
  
  dummy_ = value;
  // @@protoc_insertion_point(field_set:proto.UserListRequest.dummy)
}

// -------------------------------------------------------------------

// UserList

// .proto.UserList.ErrorCode error_code = 1;
inline void UserList::clear_error_code() {
  error_code_ = 0;
}
inline ::proto::UserList_ErrorCode UserList::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserList.error_code)
  return static_cast< ::proto::UserList_ErrorCode >(error_code_);
}
inline void UserList::set_error_code(::proto::UserList_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:proto.UserList.error_code)
}

// repeated .proto.User user = 2;
inline int UserList::user_size() const {
  return user_.size();
}
inline void UserList::clear_user() {
  user_.Clear();
}
inline const ::proto::User& UserList::user(int index) const {
  // @@protoc_insertion_point(field_get:proto.UserList.user)
  return user_.Get(index);
}
inline ::proto::User* UserList::mutable_user(int index) {
  // @@protoc_insertion_point(field_mutable:proto.UserList.user)
  return user_.Mutable(index);
}
inline ::proto::User* UserList::add_user() {
  // @@protoc_insertion_point(field_add:proto.UserList.user)
  return user_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::proto::User >*
UserList::mutable_user() {
  // @@protoc_insertion_point(field_mutable_list:proto.UserList.user)
  return &user_;
}
inline const ::google::protobuf::RepeatedPtrField< ::proto::User >&
UserList::user() const {
  // @@protoc_insertion_point(field_list:proto.UserList.user)
  return user_;
}

// -------------------------------------------------------------------

// UserRequest

// .proto.UserRequestType type = 1;
inline void UserRequest::clear_type() {
  type_ = 0;
}
inline ::proto::UserRequestType UserRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.type)
  return static_cast< ::proto::UserRequestType >(type_);
}
inline void UserRequest::set_type(::proto::UserRequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.UserRequest.type)
}

// .proto.User user = 2;
inline bool UserRequest::has_user() const {
  return this != internal_default_instance() && user_ != NULL;
}
inline void UserRequest::clear_user() {
  if (GetArenaNoVirtual() == NULL && user_ != NULL) delete user_;
  user_ = NULL;
}
inline const ::proto::User& UserRequest::user() const {
  // @@protoc_insertion_point(field_get:proto.UserRequest.user)
  return user_ != NULL ? *user_
                         : *::proto::User::internal_default_instance();
}
inline ::proto::User* UserRequest::mutable_user() {
  
  if (user_ == NULL) {
    user_ = new ::proto::User;
  }
  // @@protoc_insertion_point(field_mutable:proto.UserRequest.user)
  return user_;
}
inline ::proto::User* UserRequest::release_user() {
  // @@protoc_insertion_point(field_release:proto.UserRequest.user)
  
  ::proto::User* temp = user_;
  user_ = NULL;
  return temp;
}
inline void UserRequest::set_allocated_user(::proto::User* user) {
  delete user_;
  user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.UserRequest.user)
}

// -------------------------------------------------------------------

// UserResult

// .proto.UserRequestType type = 1;
inline void UserResult::clear_type() {
  type_ = 0;
}
inline ::proto::UserRequestType UserResult::type() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.type)
  return static_cast< ::proto::UserRequestType >(type_);
}
inline void UserResult::set_type(::proto::UserRequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.UserResult.type)
}

// .proto.UserResult.ErrorCode error_code = 2;
inline void UserResult::clear_error_code() {
  error_code_ = 0;
}
inline ::proto::UserResult_ErrorCode UserResult::error_code() const {
  // @@protoc_insertion_point(field_get:proto.UserResult.error_code)
  return static_cast< ::proto::UserResult_ErrorCode >(error_code_);
}
inline void UserResult::set_error_code(::proto::UserResult_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:proto.UserResult.error_code)
}

// -------------------------------------------------------------------

// RouterToAdmin

// .proto.SessionList session_list = 1;
inline bool RouterToAdmin::has_session_list() const {
  return this != internal_default_instance() && session_list_ != NULL;
}
inline void RouterToAdmin::clear_session_list() {
  if (GetArenaNoVirtual() == NULL && session_list_ != NULL) delete session_list_;
  session_list_ = NULL;
}
inline const ::proto::SessionList& RouterToAdmin::session_list() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.session_list)
  return session_list_ != NULL ? *session_list_
                         : *::proto::SessionList::internal_default_instance();
}
inline ::proto::SessionList* RouterToAdmin::mutable_session_list() {
  
  if (session_list_ == NULL) {
    session_list_ = new ::proto::SessionList;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.session_list)
  return session_list_;
}
inline ::proto::SessionList* RouterToAdmin::release_session_list() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.session_list)
  
  ::proto::SessionList* temp = session_list_;
  session_list_ = NULL;
  return temp;
}
inline void RouterToAdmin::set_allocated_session_list(::proto::SessionList* session_list) {
  delete session_list_;
  session_list_ = session_list;
  if (session_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.session_list)
}

// .proto.SessionResult session_result = 2;
inline bool RouterToAdmin::has_session_result() const {
  return this != internal_default_instance() && session_result_ != NULL;
}
inline void RouterToAdmin::clear_session_result() {
  if (GetArenaNoVirtual() == NULL && session_result_ != NULL) delete session_result_;
  session_result_ = NULL;
}
inline const ::proto::SessionResult& RouterToAdmin::session_result() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.session_result)
  return session_result_ != NULL ? *session_result_
                         : *::proto::SessionResult::internal_default_instance();
}
inline ::proto::SessionResult* RouterToAdmin::mutable_session_result() {
  
  if (session_result_ == NULL) {
    session_result_ = new ::proto::SessionResult;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.session_result)
  return session_result_;
}
inline ::proto::SessionResult* RouterToAdmin::release_session_result() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.session_result)
  
  ::proto::SessionResult* temp = session_result_;
  session_result_ = NULL;
  return temp;
}
inline void RouterToAdmin::set_allocated_session_result(::proto::SessionResult* session_result) {
  delete session_result_;
  session_result_ = session_result;
  if (session_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.session_result)
}

// .proto.UserList user_list = 3;
inline bool RouterToAdmin::has_user_list() const {
  return this != internal_default_instance() && user_list_ != NULL;
}
inline void RouterToAdmin::clear_user_list() {
  if (GetArenaNoVirtual() == NULL && user_list_ != NULL) delete user_list_;
  user_list_ = NULL;
}
inline const ::proto::UserList& RouterToAdmin::user_list() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.user_list)
  return user_list_ != NULL ? *user_list_
                         : *::proto::UserList::internal_default_instance();
}
inline ::proto::UserList* RouterToAdmin::mutable_user_list() {
  
  if (user_list_ == NULL) {
    user_list_ = new ::proto::UserList;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.user_list)
  return user_list_;
}
inline ::proto::UserList* RouterToAdmin::release_user_list() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.user_list)
  
  ::proto::UserList* temp = user_list_;
  user_list_ = NULL;
  return temp;
}
inline void RouterToAdmin::set_allocated_user_list(::proto::UserList* user_list) {
  delete user_list_;
  user_list_ = user_list;
  if (user_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.user_list)
}

// .proto.UserResult user_result = 4;
inline bool RouterToAdmin::has_user_result() const {
  return this != internal_default_instance() && user_result_ != NULL;
}
inline void RouterToAdmin::clear_user_result() {
  if (GetArenaNoVirtual() == NULL && user_result_ != NULL) delete user_result_;
  user_result_ = NULL;
}
inline const ::proto::UserResult& RouterToAdmin::user_result() const {
  // @@protoc_insertion_point(field_get:proto.RouterToAdmin.user_result)
  return user_result_ != NULL ? *user_result_
                         : *::proto::UserResult::internal_default_instance();
}
inline ::proto::UserResult* RouterToAdmin::mutable_user_result() {
  
  if (user_result_ == NULL) {
    user_result_ = new ::proto::UserResult;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToAdmin.user_result)
  return user_result_;
}
inline ::proto::UserResult* RouterToAdmin::release_user_result() {
  // @@protoc_insertion_point(field_release:proto.RouterToAdmin.user_result)
  
  ::proto::UserResult* temp = user_result_;
  user_result_ = NULL;
  return temp;
}
inline void RouterToAdmin::set_allocated_user_result(::proto::UserResult* user_result) {
  delete user_result_;
  user_result_ = user_result;
  if (user_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToAdmin.user_result)
}

// -------------------------------------------------------------------

// AdminToRouter

// .proto.SessionListRequest session_list_request = 1;
inline bool AdminToRouter::has_session_list_request() const {
  return this != internal_default_instance() && session_list_request_ != NULL;
}
inline void AdminToRouter::clear_session_list_request() {
  if (GetArenaNoVirtual() == NULL && session_list_request_ != NULL) delete session_list_request_;
  session_list_request_ = NULL;
}
inline const ::proto::SessionListRequest& AdminToRouter::session_list_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.session_list_request)
  return session_list_request_ != NULL ? *session_list_request_
                         : *::proto::SessionListRequest::internal_default_instance();
}
inline ::proto::SessionListRequest* AdminToRouter::mutable_session_list_request() {
  
  if (session_list_request_ == NULL) {
    session_list_request_ = new ::proto::SessionListRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.session_list_request)
  return session_list_request_;
}
inline ::proto::SessionListRequest* AdminToRouter::release_session_list_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.session_list_request)
  
  ::proto::SessionListRequest* temp = session_list_request_;
  session_list_request_ = NULL;
  return temp;
}
inline void AdminToRouter::set_allocated_session_list_request(::proto::SessionListRequest* session_list_request) {
  delete session_list_request_;
  session_list_request_ = session_list_request;
  if (session_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.session_list_request)
}

// .proto.SessionRequest session_request = 2;
inline bool AdminToRouter::has_session_request() const {
  return this != internal_default_instance() && session_request_ != NULL;
}
inline void AdminToRouter::clear_session_request() {
  if (GetArenaNoVirtual() == NULL && session_request_ != NULL) delete session_request_;
  session_request_ = NULL;
}
inline const ::proto::SessionRequest& AdminToRouter::session_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.session_request)
  return session_request_ != NULL ? *session_request_
                         : *::proto::SessionRequest::internal_default_instance();
}
inline ::proto::SessionRequest* AdminToRouter::mutable_session_request() {
  
  if (session_request_ == NULL) {
    session_request_ = new ::proto::SessionRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.session_request)
  return session_request_;
}
inline ::proto::SessionRequest* AdminToRouter::release_session_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.session_request)
  
  ::proto::SessionRequest* temp = session_request_;
  session_request_ = NULL;
  return temp;
}
inline void AdminToRouter::set_allocated_session_request(::proto::SessionRequest* session_request) {
  delete session_request_;
  session_request_ = session_request;
  if (session_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.session_request)
}

// .proto.UserListRequest user_list_request = 3;
inline bool AdminToRouter::has_user_list_request() const {
  return this != internal_default_instance() && user_list_request_ != NULL;
}
inline void AdminToRouter::clear_user_list_request() {
  if (GetArenaNoVirtual() == NULL && user_list_request_ != NULL) delete user_list_request_;
  user_list_request_ = NULL;
}
inline const ::proto::UserListRequest& AdminToRouter::user_list_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.user_list_request)
  return user_list_request_ != NULL ? *user_list_request_
                         : *::proto::UserListRequest::internal_default_instance();
}
inline ::proto::UserListRequest* AdminToRouter::mutable_user_list_request() {
  
  if (user_list_request_ == NULL) {
    user_list_request_ = new ::proto::UserListRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.user_list_request)
  return user_list_request_;
}
inline ::proto::UserListRequest* AdminToRouter::release_user_list_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.user_list_request)
  
  ::proto::UserListRequest* temp = user_list_request_;
  user_list_request_ = NULL;
  return temp;
}
inline void AdminToRouter::set_allocated_user_list_request(::proto::UserListRequest* user_list_request) {
  delete user_list_request_;
  user_list_request_ = user_list_request;
  if (user_list_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.user_list_request)
}

// .proto.UserRequest user_request = 4;
inline bool AdminToRouter::has_user_request() const {
  return this != internal_default_instance() && user_request_ != NULL;
}
inline void AdminToRouter::clear_user_request() {
  if (GetArenaNoVirtual() == NULL && user_request_ != NULL) delete user_request_;
  user_request_ = NULL;
}
inline const ::proto::UserRequest& AdminToRouter::user_request() const {
  // @@protoc_insertion_point(field_get:proto.AdminToRouter.user_request)
  return user_request_ != NULL ? *user_request_
                         : *::proto::UserRequest::internal_default_instance();
}
inline ::proto::UserRequest* AdminToRouter::mutable_user_request() {
  
  if (user_request_ == NULL) {
    user_request_ = new ::proto::UserRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.AdminToRouter.user_request)
  return user_request_;
}
inline ::proto::UserRequest* AdminToRouter::release_user_request() {
  // @@protoc_insertion_point(field_release:proto.AdminToRouter.user_request)
  
  ::proto::UserRequest* temp = user_request_;
  user_request_ = NULL;
  return temp;
}
inline void AdminToRouter::set_allocated_user_request(::proto::UserRequest* user_request) {
  delete user_request_;
  user_request_ = user_request;
  if (user_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.AdminToRouter.user_request)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::SessionResult_ErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::SessionList_ErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::UserList_ErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::UserResult_ErrorCode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::SessionRequestType> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::UserRequestType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_router_5fadmin_2eproto__INCLUDED
