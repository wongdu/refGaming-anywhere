// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router_peer.proto

#ifndef PROTOBUF_router_5fpeer_2eproto__INCLUDED
#define PROTOBUF_router_5fpeer_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "router_common.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
class ConnectionOffer;
class ConnectionOfferDefaultTypeInternal;
extern ConnectionOfferDefaultTypeInternal _ConnectionOffer_default_instance_;
class ConnectionRequest;
class ConnectionRequestDefaultTypeInternal;
extern ConnectionRequestDefaultTypeInternal _ConnectionRequest_default_instance_;
class HostIdRequest;
class HostIdRequestDefaultTypeInternal;
extern HostIdRequestDefaultTypeInternal _HostIdRequest_default_instance_;
class HostIdResponse;
class HostIdResponseDefaultTypeInternal;
extern HostIdResponseDefaultTypeInternal _HostIdResponse_default_instance_;
class PeerToRouter;
class PeerToRouterDefaultTypeInternal;
extern PeerToRouterDefaultTypeInternal _PeerToRouter_default_instance_;
class RelayCredentials;
class RelayCredentialsDefaultTypeInternal;
extern RelayCredentialsDefaultTypeInternal _RelayCredentials_default_instance_;
class RelayKey;
class RelayKeyDefaultTypeInternal;
extern RelayKeyDefaultTypeInternal _RelayKey_default_instance_;
class ResetHostId;
class ResetHostIdDefaultTypeInternal;
extern ResetHostIdDefaultTypeInternal _ResetHostId_default_instance_;
class RouterToPeer;
class RouterToPeerDefaultTypeInternal;
extern RouterToPeerDefaultTypeInternal _RouterToPeer_default_instance_;
}  // namespace proto

namespace proto {

namespace protobuf_router_5fpeer_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_router_5fpeer_2eproto

enum HostIdRequest_Type {
  HostIdRequest_Type_UNKNOWN = 0,
  HostIdRequest_Type_NEW_ID = 1,
  HostIdRequest_Type_EXISTING_ID = 2,
  HostIdRequest_Type_HostIdRequest_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HostIdRequest_Type_HostIdRequest_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HostIdRequest_Type_IsValid(int value);
const HostIdRequest_Type HostIdRequest_Type_Type_MIN = HostIdRequest_Type_UNKNOWN;
const HostIdRequest_Type HostIdRequest_Type_Type_MAX = HostIdRequest_Type_EXISTING_ID;
const int HostIdRequest_Type_Type_ARRAYSIZE = HostIdRequest_Type_Type_MAX + 1;

enum ConnectionOffer_PeerRole {
  ConnectionOffer_PeerRole_HOST = 0,
  ConnectionOffer_PeerRole_CLIENT = 1,
  ConnectionOffer_PeerRole_ConnectionOffer_PeerRole_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionOffer_PeerRole_ConnectionOffer_PeerRole_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionOffer_PeerRole_IsValid(int value);
const ConnectionOffer_PeerRole ConnectionOffer_PeerRole_PeerRole_MIN = ConnectionOffer_PeerRole_HOST;
const ConnectionOffer_PeerRole ConnectionOffer_PeerRole_PeerRole_MAX = ConnectionOffer_PeerRole_CLIENT;
const int ConnectionOffer_PeerRole_PeerRole_ARRAYSIZE = ConnectionOffer_PeerRole_PeerRole_MAX + 1;

enum ConnectionOffer_ErrorCode {
  ConnectionOffer_ErrorCode_SUCCESS = 0,
  ConnectionOffer_ErrorCode_UNKNOWN_ERROR = 1,
  ConnectionOffer_ErrorCode_PEER_NOT_FOUND = 2,
  ConnectionOffer_ErrorCode_ACCESS_DENIED = 3,
  ConnectionOffer_ErrorCode_KEY_POOL_EMPTY = 4,
  ConnectionOffer_ErrorCode_ConnectionOffer_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ConnectionOffer_ErrorCode_ConnectionOffer_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ConnectionOffer_ErrorCode_IsValid(int value);
const ConnectionOffer_ErrorCode ConnectionOffer_ErrorCode_ErrorCode_MIN = ConnectionOffer_ErrorCode_SUCCESS;
const ConnectionOffer_ErrorCode ConnectionOffer_ErrorCode_ErrorCode_MAX = ConnectionOffer_ErrorCode_KEY_POOL_EMPTY;
const int ConnectionOffer_ErrorCode_ErrorCode_ARRAYSIZE = ConnectionOffer_ErrorCode_ErrorCode_MAX + 1;

// ===================================================================

class HostIdRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostIdRequest) */ {
 public:
  HostIdRequest();
  virtual ~HostIdRequest();

  HostIdRequest(const HostIdRequest& from);

  inline HostIdRequest& operator=(const HostIdRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const HostIdRequest& default_instance();

  static inline const HostIdRequest* internal_default_instance() {
    return reinterpret_cast<const HostIdRequest*>(
               &_HostIdRequest_default_instance_);
  }

  void Swap(HostIdRequest* other);

  // implements Message ----------------------------------------------

  inline HostIdRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HostIdRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HostIdRequest& from);
  void MergeFrom(const HostIdRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostIdRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HostIdRequest_Type Type;
  static const Type UNKNOWN =
    HostIdRequest_Type_UNKNOWN;
  static const Type NEW_ID =
    HostIdRequest_Type_NEW_ID;
  static const Type EXISTING_ID =
    HostIdRequest_Type_EXISTING_ID;
  static inline bool Type_IsValid(int value) {
    return HostIdRequest_Type_IsValid(value);
  }
  static const Type Type_MIN =
    HostIdRequest_Type_Type_MIN;
  static const Type Type_MAX =
    HostIdRequest_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    HostIdRequest_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .proto.HostIdRequest.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::proto::HostIdRequest_Type type() const;
  void set_type(::proto::HostIdRequest_Type value);

  // @@protoc_insertion_point(class_scope:proto.HostIdRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  int type_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetHostId : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ResetHostId) */ {
 public:
  ResetHostId();
  virtual ~ResetHostId();

  ResetHostId(const ResetHostId& from);

  inline ResetHostId& operator=(const ResetHostId& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResetHostId& default_instance();

  static inline const ResetHostId* internal_default_instance() {
    return reinterpret_cast<const ResetHostId*>(
               &_ResetHostId_default_instance_);
  }

  void Swap(ResetHostId* other);

  // implements Message ----------------------------------------------

  inline ResetHostId* New() const PROTOBUF_FINAL { return New(NULL); }

  ResetHostId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ResetHostId& from);
  void MergeFrom(const ResetHostId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ResetHostId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 host_id = 1;
  void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  ::google::protobuf::uint64 host_id() const;
  void set_host_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.ResetHostId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 host_id_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HostIdResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.HostIdResponse) */ {
 public:
  HostIdResponse();
  virtual ~HostIdResponse();

  HostIdResponse(const HostIdResponse& from);

  inline HostIdResponse& operator=(const HostIdResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const HostIdResponse& default_instance();

  static inline const HostIdResponse* internal_default_instance() {
    return reinterpret_cast<const HostIdResponse*>(
               &_HostIdResponse_default_instance_);
  }

  void Swap(HostIdResponse* other);

  // implements Message ----------------------------------------------

  inline HostIdResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  HostIdResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HostIdResponse& from);
  void MergeFrom(const HostIdResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostIdResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // fixed64 host_id = 1;
  void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  ::google::protobuf::uint64 host_id() const;
  void set_host_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.HostIdResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 host_id_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectionRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ConnectionRequest) */ {
 public:
  ConnectionRequest();
  virtual ~ConnectionRequest();

  ConnectionRequest(const ConnectionRequest& from);

  inline ConnectionRequest& operator=(const ConnectionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectionRequest& default_instance();

  static inline const ConnectionRequest* internal_default_instance() {
    return reinterpret_cast<const ConnectionRequest*>(
               &_ConnectionRequest_default_instance_);
  }

  void Swap(ConnectionRequest* other);

  // implements Message ----------------------------------------------

  inline ConnectionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ConnectionRequest& from);
  void MergeFrom(const ConnectionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 host_id = 1;
  void clear_host_id();
  static const int kHostIdFieldNumber = 1;
  ::google::protobuf::uint64 host_id() const;
  void set_host_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:proto.ConnectionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::uint64 host_id_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConnectionOffer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ConnectionOffer) */ {
 public:
  ConnectionOffer();
  virtual ~ConnectionOffer();

  ConnectionOffer(const ConnectionOffer& from);

  inline ConnectionOffer& operator=(const ConnectionOffer& from) {
    CopyFrom(from);
    return *this;
  }

  static const ConnectionOffer& default_instance();

  static inline const ConnectionOffer* internal_default_instance() {
    return reinterpret_cast<const ConnectionOffer*>(
               &_ConnectionOffer_default_instance_);
  }

  void Swap(ConnectionOffer* other);

  // implements Message ----------------------------------------------

  inline ConnectionOffer* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectionOffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ConnectionOffer& from);
  void MergeFrom(const ConnectionOffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectionOffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ConnectionOffer_PeerRole PeerRole;
  static const PeerRole HOST =
    ConnectionOffer_PeerRole_HOST;
  static const PeerRole CLIENT =
    ConnectionOffer_PeerRole_CLIENT;
  static inline bool PeerRole_IsValid(int value) {
    return ConnectionOffer_PeerRole_IsValid(value);
  }
  static const PeerRole PeerRole_MIN =
    ConnectionOffer_PeerRole_PeerRole_MIN;
  static const PeerRole PeerRole_MAX =
    ConnectionOffer_PeerRole_PeerRole_MAX;
  static const int PeerRole_ARRAYSIZE =
    ConnectionOffer_PeerRole_PeerRole_ARRAYSIZE;

  typedef ConnectionOffer_ErrorCode ErrorCode;
  static const ErrorCode SUCCESS =
    ConnectionOffer_ErrorCode_SUCCESS;
  static const ErrorCode UNKNOWN_ERROR =
    ConnectionOffer_ErrorCode_UNKNOWN_ERROR;
  static const ErrorCode PEER_NOT_FOUND =
    ConnectionOffer_ErrorCode_PEER_NOT_FOUND;
  static const ErrorCode ACCESS_DENIED =
    ConnectionOffer_ErrorCode_ACCESS_DENIED;
  static const ErrorCode KEY_POOL_EMPTY =
    ConnectionOffer_ErrorCode_KEY_POOL_EMPTY;
  static inline bool ErrorCode_IsValid(int value) {
    return ConnectionOffer_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    ConnectionOffer_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    ConnectionOffer_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    ConnectionOffer_ErrorCode_ErrorCode_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // .proto.RelayCredentials relay = 3;
  bool has_relay() const;
  void clear_relay();
  static const int kRelayFieldNumber = 3;
  const ::proto::RelayCredentials& relay() const;
  ::proto::RelayCredentials* mutable_relay();
  ::proto::RelayCredentials* release_relay();
  void set_allocated_relay(::proto::RelayCredentials* relay);

  // .proto.ConnectionOffer.PeerRole peer_role = 1;
  void clear_peer_role();
  static const int kPeerRoleFieldNumber = 1;
  ::proto::ConnectionOffer_PeerRole peer_role() const;
  void set_peer_role(::proto::ConnectionOffer_PeerRole value);

  // .proto.ConnectionOffer.ErrorCode error_code = 2;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 2;
  ::proto::ConnectionOffer_ErrorCode error_code() const;
  void set_error_code(::proto::ConnectionOffer_ErrorCode value);

  // @@protoc_insertion_point(class_scope:proto.ConnectionOffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::RelayCredentials* relay_;
  int peer_role_;
  int error_code_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouterToPeer : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.RouterToPeer) */ {
 public:
  RouterToPeer();
  virtual ~RouterToPeer();

  RouterToPeer(const RouterToPeer& from);

  inline RouterToPeer& operator=(const RouterToPeer& from) {
    CopyFrom(from);
    return *this;
  }

  static const RouterToPeer& default_instance();

  static inline const RouterToPeer* internal_default_instance() {
    return reinterpret_cast<const RouterToPeer*>(
               &_RouterToPeer_default_instance_);
  }

  void Swap(RouterToPeer* other);

  // implements Message ----------------------------------------------

  inline RouterToPeer* New() const PROTOBUF_FINAL { return New(NULL); }

  RouterToPeer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const RouterToPeer& from);
  void MergeFrom(const RouterToPeer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RouterToPeer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.HostIdResponse host_id_response = 1;
  bool has_host_id_response() const;
  void clear_host_id_response();
  static const int kHostIdResponseFieldNumber = 1;
  const ::proto::HostIdResponse& host_id_response() const;
  ::proto::HostIdResponse* mutable_host_id_response();
  ::proto::HostIdResponse* release_host_id_response();
  void set_allocated_host_id_response(::proto::HostIdResponse* host_id_response);

  // .proto.ConnectionOffer connection_offer = 2;
  bool has_connection_offer() const;
  void clear_connection_offer();
  static const int kConnectionOfferFieldNumber = 2;
  const ::proto::ConnectionOffer& connection_offer() const;
  ::proto::ConnectionOffer* mutable_connection_offer();
  ::proto::ConnectionOffer* release_connection_offer();
  void set_allocated_connection_offer(::proto::ConnectionOffer* connection_offer);

  // @@protoc_insertion_point(class_scope:proto.RouterToPeer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::HostIdResponse* host_id_response_;
  ::proto::ConnectionOffer* connection_offer_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PeerToRouter : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.PeerToRouter) */ {
 public:
  PeerToRouter();
  virtual ~PeerToRouter();

  PeerToRouter(const PeerToRouter& from);

  inline PeerToRouter& operator=(const PeerToRouter& from) {
    CopyFrom(from);
    return *this;
  }

  static const PeerToRouter& default_instance();

  static inline const PeerToRouter* internal_default_instance() {
    return reinterpret_cast<const PeerToRouter*>(
               &_PeerToRouter_default_instance_);
  }

  void Swap(PeerToRouter* other);

  // implements Message ----------------------------------------------

  inline PeerToRouter* New() const PROTOBUF_FINAL { return New(NULL); }

  PeerToRouter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const PeerToRouter& from);
  void MergeFrom(const PeerToRouter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PeerToRouter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .proto.ConnectionRequest connection_request = 1;
  bool has_connection_request() const;
  void clear_connection_request();
  static const int kConnectionRequestFieldNumber = 1;
  const ::proto::ConnectionRequest& connection_request() const;
  ::proto::ConnectionRequest* mutable_connection_request();
  ::proto::ConnectionRequest* release_connection_request();
  void set_allocated_connection_request(::proto::ConnectionRequest* connection_request);

  // .proto.HostIdRequest host_id_request = 2;
  bool has_host_id_request() const;
  void clear_host_id_request();
  static const int kHostIdRequestFieldNumber = 2;
  const ::proto::HostIdRequest& host_id_request() const;
  ::proto::HostIdRequest* mutable_host_id_request();
  ::proto::HostIdRequest* release_host_id_request();
  void set_allocated_host_id_request(::proto::HostIdRequest* host_id_request);

  // .proto.ResetHostId reset_host_id = 3;
  bool has_reset_host_id() const;
  void clear_reset_host_id();
  static const int kResetHostIdFieldNumber = 3;
  const ::proto::ResetHostId& reset_host_id() const;
  ::proto::ResetHostId* mutable_reset_host_id();
  ::proto::ResetHostId* release_reset_host_id();
  void set_allocated_reset_host_id(::proto::ResetHostId* reset_host_id);

  // @@protoc_insertion_point(class_scope:proto.PeerToRouter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::proto::ConnectionRequest* connection_request_;
  ::proto::HostIdRequest* host_id_request_;
  ::proto::ResetHostId* reset_host_id_;
  mutable int _cached_size_;
  friend struct  protobuf_router_5fpeer_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// HostIdRequest

// .proto.HostIdRequest.Type type = 1;
inline void HostIdRequest::clear_type() {
  type_ = 0;
}
inline ::proto::HostIdRequest_Type HostIdRequest::type() const {
  // @@protoc_insertion_point(field_get:proto.HostIdRequest.type)
  return static_cast< ::proto::HostIdRequest_Type >(type_);
}
inline void HostIdRequest::set_type(::proto::HostIdRequest_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:proto.HostIdRequest.type)
}

// bytes key = 2;
inline void HostIdRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostIdRequest::key() const {
  // @@protoc_insertion_point(field_get:proto.HostIdRequest.key)
  return key_.GetNoArena();
}
inline void HostIdRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.HostIdRequest.key)
}
#if LANG_CXX11
inline void HostIdRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.HostIdRequest.key)
}
#endif
inline void HostIdRequest::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.HostIdRequest.key)
}
inline void HostIdRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.HostIdRequest.key)
}
inline ::std::string* HostIdRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:proto.HostIdRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostIdRequest::release_key() {
  // @@protoc_insertion_point(field_release:proto.HostIdRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostIdRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:proto.HostIdRequest.key)
}

// -------------------------------------------------------------------

// ResetHostId

// fixed64 host_id = 1;
inline void ResetHostId::clear_host_id() {
  host_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResetHostId::host_id() const {
  // @@protoc_insertion_point(field_get:proto.ResetHostId.host_id)
  return host_id_;
}
inline void ResetHostId::set_host_id(::google::protobuf::uint64 value) {
  
  host_id_ = value;
  // @@protoc_insertion_point(field_set:proto.ResetHostId.host_id)
}

// -------------------------------------------------------------------

// HostIdResponse

// fixed64 host_id = 1;
inline void HostIdResponse::clear_host_id() {
  host_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HostIdResponse::host_id() const {
  // @@protoc_insertion_point(field_get:proto.HostIdResponse.host_id)
  return host_id_;
}
inline void HostIdResponse::set_host_id(::google::protobuf::uint64 value) {
  
  host_id_ = value;
  // @@protoc_insertion_point(field_set:proto.HostIdResponse.host_id)
}

// bytes key = 2;
inline void HostIdResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HostIdResponse::key() const {
  // @@protoc_insertion_point(field_get:proto.HostIdResponse.key)
  return key_.GetNoArena();
}
inline void HostIdResponse::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.HostIdResponse.key)
}
#if LANG_CXX11
inline void HostIdResponse::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.HostIdResponse.key)
}
#endif
inline void HostIdResponse::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.HostIdResponse.key)
}
inline void HostIdResponse::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.HostIdResponse.key)
}
inline ::std::string* HostIdResponse::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:proto.HostIdResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostIdResponse::release_key() {
  // @@protoc_insertion_point(field_release:proto.HostIdResponse.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostIdResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:proto.HostIdResponse.key)
}

// -------------------------------------------------------------------

// ConnectionRequest

// fixed64 host_id = 1;
inline void ConnectionRequest::clear_host_id() {
  host_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ConnectionRequest::host_id() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionRequest.host_id)
  return host_id_;
}
inline void ConnectionRequest::set_host_id(::google::protobuf::uint64 value) {
  
  host_id_ = value;
  // @@protoc_insertion_point(field_set:proto.ConnectionRequest.host_id)
}

// -------------------------------------------------------------------

// ConnectionOffer

// .proto.ConnectionOffer.PeerRole peer_role = 1;
inline void ConnectionOffer::clear_peer_role() {
  peer_role_ = 0;
}
inline ::proto::ConnectionOffer_PeerRole ConnectionOffer::peer_role() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.peer_role)
  return static_cast< ::proto::ConnectionOffer_PeerRole >(peer_role_);
}
inline void ConnectionOffer::set_peer_role(::proto::ConnectionOffer_PeerRole value) {
  
  peer_role_ = value;
  // @@protoc_insertion_point(field_set:proto.ConnectionOffer.peer_role)
}

// .proto.ConnectionOffer.ErrorCode error_code = 2;
inline void ConnectionOffer::clear_error_code() {
  error_code_ = 0;
}
inline ::proto::ConnectionOffer_ErrorCode ConnectionOffer::error_code() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.error_code)
  return static_cast< ::proto::ConnectionOffer_ErrorCode >(error_code_);
}
inline void ConnectionOffer::set_error_code(::proto::ConnectionOffer_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:proto.ConnectionOffer.error_code)
}

// .proto.RelayCredentials relay = 3;
inline bool ConnectionOffer::has_relay() const {
  return this != internal_default_instance() && relay_ != NULL;
}
inline void ConnectionOffer::clear_relay() {
  if (GetArenaNoVirtual() == NULL && relay_ != NULL) delete relay_;
  relay_ = NULL;
}
inline const ::proto::RelayCredentials& ConnectionOffer::relay() const {
  // @@protoc_insertion_point(field_get:proto.ConnectionOffer.relay)
  return relay_ != NULL ? *relay_
                         : *::proto::RelayCredentials::internal_default_instance();
}
inline ::proto::RelayCredentials* ConnectionOffer::mutable_relay() {
  
  if (relay_ == NULL) {
    relay_ = new ::proto::RelayCredentials;
  }
  // @@protoc_insertion_point(field_mutable:proto.ConnectionOffer.relay)
  return relay_;
}
inline ::proto::RelayCredentials* ConnectionOffer::release_relay() {
  // @@protoc_insertion_point(field_release:proto.ConnectionOffer.relay)
  
  ::proto::RelayCredentials* temp = relay_;
  relay_ = NULL;
  return temp;
}
inline void ConnectionOffer::set_allocated_relay(::proto::RelayCredentials* relay) {
  delete relay_;
  relay_ = relay;
  if (relay) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.ConnectionOffer.relay)
}

// -------------------------------------------------------------------

// RouterToPeer

// .proto.HostIdResponse host_id_response = 1;
inline bool RouterToPeer::has_host_id_response() const {
  return this != internal_default_instance() && host_id_response_ != NULL;
}
inline void RouterToPeer::clear_host_id_response() {
  if (GetArenaNoVirtual() == NULL && host_id_response_ != NULL) delete host_id_response_;
  host_id_response_ = NULL;
}
inline const ::proto::HostIdResponse& RouterToPeer::host_id_response() const {
  // @@protoc_insertion_point(field_get:proto.RouterToPeer.host_id_response)
  return host_id_response_ != NULL ? *host_id_response_
                         : *::proto::HostIdResponse::internal_default_instance();
}
inline ::proto::HostIdResponse* RouterToPeer::mutable_host_id_response() {
  
  if (host_id_response_ == NULL) {
    host_id_response_ = new ::proto::HostIdResponse;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToPeer.host_id_response)
  return host_id_response_;
}
inline ::proto::HostIdResponse* RouterToPeer::release_host_id_response() {
  // @@protoc_insertion_point(field_release:proto.RouterToPeer.host_id_response)
  
  ::proto::HostIdResponse* temp = host_id_response_;
  host_id_response_ = NULL;
  return temp;
}
inline void RouterToPeer::set_allocated_host_id_response(::proto::HostIdResponse* host_id_response) {
  delete host_id_response_;
  host_id_response_ = host_id_response;
  if (host_id_response) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToPeer.host_id_response)
}

// .proto.ConnectionOffer connection_offer = 2;
inline bool RouterToPeer::has_connection_offer() const {
  return this != internal_default_instance() && connection_offer_ != NULL;
}
inline void RouterToPeer::clear_connection_offer() {
  if (GetArenaNoVirtual() == NULL && connection_offer_ != NULL) delete connection_offer_;
  connection_offer_ = NULL;
}
inline const ::proto::ConnectionOffer& RouterToPeer::connection_offer() const {
  // @@protoc_insertion_point(field_get:proto.RouterToPeer.connection_offer)
  return connection_offer_ != NULL ? *connection_offer_
                         : *::proto::ConnectionOffer::internal_default_instance();
}
inline ::proto::ConnectionOffer* RouterToPeer::mutable_connection_offer() {
  
  if (connection_offer_ == NULL) {
    connection_offer_ = new ::proto::ConnectionOffer;
  }
  // @@protoc_insertion_point(field_mutable:proto.RouterToPeer.connection_offer)
  return connection_offer_;
}
inline ::proto::ConnectionOffer* RouterToPeer::release_connection_offer() {
  // @@protoc_insertion_point(field_release:proto.RouterToPeer.connection_offer)
  
  ::proto::ConnectionOffer* temp = connection_offer_;
  connection_offer_ = NULL;
  return temp;
}
inline void RouterToPeer::set_allocated_connection_offer(::proto::ConnectionOffer* connection_offer) {
  delete connection_offer_;
  connection_offer_ = connection_offer;
  if (connection_offer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.RouterToPeer.connection_offer)
}

// -------------------------------------------------------------------

// PeerToRouter

// .proto.ConnectionRequest connection_request = 1;
inline bool PeerToRouter::has_connection_request() const {
  return this != internal_default_instance() && connection_request_ != NULL;
}
inline void PeerToRouter::clear_connection_request() {
  if (GetArenaNoVirtual() == NULL && connection_request_ != NULL) delete connection_request_;
  connection_request_ = NULL;
}
inline const ::proto::ConnectionRequest& PeerToRouter::connection_request() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.connection_request)
  return connection_request_ != NULL ? *connection_request_
                         : *::proto::ConnectionRequest::internal_default_instance();
}
inline ::proto::ConnectionRequest* PeerToRouter::mutable_connection_request() {
  
  if (connection_request_ == NULL) {
    connection_request_ = new ::proto::ConnectionRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.connection_request)
  return connection_request_;
}
inline ::proto::ConnectionRequest* PeerToRouter::release_connection_request() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.connection_request)
  
  ::proto::ConnectionRequest* temp = connection_request_;
  connection_request_ = NULL;
  return temp;
}
inline void PeerToRouter::set_allocated_connection_request(::proto::ConnectionRequest* connection_request) {
  delete connection_request_;
  connection_request_ = connection_request;
  if (connection_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.connection_request)
}

// .proto.HostIdRequest host_id_request = 2;
inline bool PeerToRouter::has_host_id_request() const {
  return this != internal_default_instance() && host_id_request_ != NULL;
}
inline void PeerToRouter::clear_host_id_request() {
  if (GetArenaNoVirtual() == NULL && host_id_request_ != NULL) delete host_id_request_;
  host_id_request_ = NULL;
}
inline const ::proto::HostIdRequest& PeerToRouter::host_id_request() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.host_id_request)
  return host_id_request_ != NULL ? *host_id_request_
                         : *::proto::HostIdRequest::internal_default_instance();
}
inline ::proto::HostIdRequest* PeerToRouter::mutable_host_id_request() {
  
  if (host_id_request_ == NULL) {
    host_id_request_ = new ::proto::HostIdRequest;
  }
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.host_id_request)
  return host_id_request_;
}
inline ::proto::HostIdRequest* PeerToRouter::release_host_id_request() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.host_id_request)
  
  ::proto::HostIdRequest* temp = host_id_request_;
  host_id_request_ = NULL;
  return temp;
}
inline void PeerToRouter::set_allocated_host_id_request(::proto::HostIdRequest* host_id_request) {
  delete host_id_request_;
  host_id_request_ = host_id_request;
  if (host_id_request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.host_id_request)
}

// .proto.ResetHostId reset_host_id = 3;
inline bool PeerToRouter::has_reset_host_id() const {
  return this != internal_default_instance() && reset_host_id_ != NULL;
}
inline void PeerToRouter::clear_reset_host_id() {
  if (GetArenaNoVirtual() == NULL && reset_host_id_ != NULL) delete reset_host_id_;
  reset_host_id_ = NULL;
}
inline const ::proto::ResetHostId& PeerToRouter::reset_host_id() const {
  // @@protoc_insertion_point(field_get:proto.PeerToRouter.reset_host_id)
  return reset_host_id_ != NULL ? *reset_host_id_
                         : *::proto::ResetHostId::internal_default_instance();
}
inline ::proto::ResetHostId* PeerToRouter::mutable_reset_host_id() {
  
  if (reset_host_id_ == NULL) {
    reset_host_id_ = new ::proto::ResetHostId;
  }
  // @@protoc_insertion_point(field_mutable:proto.PeerToRouter.reset_host_id)
  return reset_host_id_;
}
inline ::proto::ResetHostId* PeerToRouter::release_reset_host_id() {
  // @@protoc_insertion_point(field_release:proto.PeerToRouter.reset_host_id)
  
  ::proto::ResetHostId* temp = reset_host_id_;
  reset_host_id_ = NULL;
  return temp;
}
inline void PeerToRouter::set_allocated_reset_host_id(::proto::ResetHostId* reset_host_id) {
  delete reset_host_id_;
  reset_host_id_ = reset_host_id;
  if (reset_host_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.PeerToRouter.reset_host_id)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::HostIdRequest_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::ConnectionOffer_PeerRole> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::ConnectionOffer_ErrorCode> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_router_5fpeer_2eproto__INCLUDED
