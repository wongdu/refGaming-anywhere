// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: key_exchange.proto

#ifndef PROTOBUF_key_5fexchange_2eproto__INCLUDED
#define PROTOBUF_key_5fexchange_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
namespace proto {
class ClientHello;
class ClientHelloDefaultTypeInternal;
extern ClientHelloDefaultTypeInternal _ClientHello_default_instance_;
class ServerHello;
class ServerHelloDefaultTypeInternal;
extern ServerHelloDefaultTypeInternal _ServerHello_default_instance_;
class SessionChallenge;
class SessionChallengeDefaultTypeInternal;
extern SessionChallengeDefaultTypeInternal _SessionChallenge_default_instance_;
class SessionResponse;
class SessionResponseDefaultTypeInternal;
extern SessionResponseDefaultTypeInternal _SessionResponse_default_instance_;
class SrpClientKeyExchange;
class SrpClientKeyExchangeDefaultTypeInternal;
extern SrpClientKeyExchangeDefaultTypeInternal _SrpClientKeyExchange_default_instance_;
class SrpIdentify;
class SrpIdentifyDefaultTypeInternal;
extern SrpIdentifyDefaultTypeInternal _SrpIdentify_default_instance_;
class SrpServerKeyExchange;
class SrpServerKeyExchangeDefaultTypeInternal;
extern SrpServerKeyExchangeDefaultTypeInternal _SrpServerKeyExchange_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
}  // namespace proto

namespace proto {

namespace protobuf_key_5fexchange_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_key_5fexchange_2eproto

enum Identify {
  IDENTIFY_SRP = 0,
  IDENTIFY_ANONYMOUS = 1,
  Identify_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Identify_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Identify_IsValid(int value);
const Identify Identify_MIN = IDENTIFY_SRP;
const Identify Identify_MAX = IDENTIFY_ANONYMOUS;
const int Identify_ARRAYSIZE = Identify_MAX + 1;

enum Encryption {
  ENCRYPTION_UNKNOWN = 0,
  ENCRYPTION_CHACHA20_POLY1305 = 1,
  ENCRYPTION_AES256_GCM = 2,
  Encryption_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Encryption_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Encryption_IsValid(int value);
const Encryption Encryption_MIN = ENCRYPTION_UNKNOWN;
const Encryption Encryption_MAX = ENCRYPTION_AES256_GCM;
const int Encryption_ARRAYSIZE = Encryption_MAX + 1;

// ===================================================================

class ClientHello : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ClientHello) */ {
 public:
  ClientHello();
  virtual ~ClientHello();

  ClientHello(const ClientHello& from);

  inline ClientHello& operator=(const ClientHello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ClientHello& default_instance();

  static inline const ClientHello* internal_default_instance() {
    return reinterpret_cast<const ClientHello*>(
               &_ClientHello_default_instance_);
  }

  void Swap(ClientHello* other);

  // implements Message ----------------------------------------------

  inline ClientHello* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientHello* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ClientHello& from);
  void MergeFrom(const ClientHello& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes public_key = 3;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // bytes iv = 4;
  void clear_iv();
  static const int kIvFieldNumber = 4;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // uint32 encryption = 1;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 1;
  ::google::protobuf::uint32 encryption() const;
  void set_encryption(::google::protobuf::uint32 value);

  // .proto.Identify identify = 2;
  void clear_identify();
  static const int kIdentifyFieldNumber = 2;
  ::proto::Identify identify() const;
  void set_identify(::proto::Identify value);

  // @@protoc_insertion_point(class_scope:proto.ClientHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::uint32 encryption_;
  int identify_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ServerHello : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.ServerHello) */ {
 public:
  ServerHello();
  virtual ~ServerHello();

  ServerHello(const ServerHello& from);

  inline ServerHello& operator=(const ServerHello& from) {
    CopyFrom(from);
    return *this;
  }

  static const ServerHello& default_instance();

  static inline const ServerHello* internal_default_instance() {
    return reinterpret_cast<const ServerHello*>(
               &_ServerHello_default_instance_);
  }

  void Swap(ServerHello* other);

  // implements Message ----------------------------------------------

  inline ServerHello* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerHello* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ServerHello& from);
  void MergeFrom(const ServerHello& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerHello* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes iv = 2;
  void clear_iv();
  static const int kIvFieldNumber = 2;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // .proto.Encryption encryption = 1;
  void clear_encryption();
  static const int kEncryptionFieldNumber = 1;
  ::proto::Encryption encryption() const;
  void set_encryption(::proto::Encryption value);

  // @@protoc_insertion_point(class_scope:proto.ServerHello)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  int encryption_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SrpIdentify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpIdentify) */ {
 public:
  SrpIdentify();
  virtual ~SrpIdentify();

  SrpIdentify(const SrpIdentify& from);

  inline SrpIdentify& operator=(const SrpIdentify& from) {
    CopyFrom(from);
    return *this;
  }

  static const SrpIdentify& default_instance();

  static inline const SrpIdentify* internal_default_instance() {
    return reinterpret_cast<const SrpIdentify*>(
               &_SrpIdentify_default_instance_);
  }

  void Swap(SrpIdentify* other);

  // implements Message ----------------------------------------------

  inline SrpIdentify* New() const PROTOBUF_FINAL { return New(NULL); }

  SrpIdentify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SrpIdentify& from);
  void MergeFrom(const SrpIdentify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpIdentify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string username = 1;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:proto.SrpIdentify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SrpServerKeyExchange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpServerKeyExchange) */ {
 public:
  SrpServerKeyExchange();
  virtual ~SrpServerKeyExchange();

  SrpServerKeyExchange(const SrpServerKeyExchange& from);

  inline SrpServerKeyExchange& operator=(const SrpServerKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }

  static const SrpServerKeyExchange& default_instance();

  static inline const SrpServerKeyExchange* internal_default_instance() {
    return reinterpret_cast<const SrpServerKeyExchange*>(
               &_SrpServerKeyExchange_default_instance_);
  }

  void Swap(SrpServerKeyExchange* other);

  // implements Message ----------------------------------------------

  inline SrpServerKeyExchange* New() const PROTOBUF_FINAL { return New(NULL); }

  SrpServerKeyExchange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SrpServerKeyExchange& from);
  void MergeFrom(const SrpServerKeyExchange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpServerKeyExchange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes number = 1;
  void clear_number();
  static const int kNumberFieldNumber = 1;
  const ::std::string& number() const;
  void set_number(const ::std::string& value);
  #if LANG_CXX11
  void set_number(::std::string&& value);
  #endif
  void set_number(const char* value);
  void set_number(const void* value, size_t size);
  ::std::string* mutable_number();
  ::std::string* release_number();
  void set_allocated_number(::std::string* number);

  // bytes generator = 2;
  void clear_generator();
  static const int kGeneratorFieldNumber = 2;
  const ::std::string& generator() const;
  void set_generator(const ::std::string& value);
  #if LANG_CXX11
  void set_generator(::std::string&& value);
  #endif
  void set_generator(const char* value);
  void set_generator(const void* value, size_t size);
  ::std::string* mutable_generator();
  ::std::string* release_generator();
  void set_allocated_generator(::std::string* generator);

  // bytes salt = 3;
  void clear_salt();
  static const int kSaltFieldNumber = 3;
  const ::std::string& salt() const;
  void set_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_salt(::std::string&& value);
  #endif
  void set_salt(const char* value);
  void set_salt(const void* value, size_t size);
  ::std::string* mutable_salt();
  ::std::string* release_salt();
  void set_allocated_salt(::std::string* salt);

  // bytes B = 4;
  void clear_b();
  static const int kBFieldNumber = 4;
  const ::std::string& b() const;
  void set_b(const ::std::string& value);
  #if LANG_CXX11
  void set_b(::std::string&& value);
  #endif
  void set_b(const char* value);
  void set_b(const void* value, size_t size);
  ::std::string* mutable_b();
  ::std::string* release_b();
  void set_allocated_b(::std::string* b);

  // bytes iv = 5;
  void clear_iv();
  static const int kIvFieldNumber = 5;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // @@protoc_insertion_point(class_scope:proto.SrpServerKeyExchange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr number_;
  ::google::protobuf::internal::ArenaStringPtr generator_;
  ::google::protobuf::internal::ArenaStringPtr salt_;
  ::google::protobuf::internal::ArenaStringPtr b_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SrpClientKeyExchange : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SrpClientKeyExchange) */ {
 public:
  SrpClientKeyExchange();
  virtual ~SrpClientKeyExchange();

  SrpClientKeyExchange(const SrpClientKeyExchange& from);

  inline SrpClientKeyExchange& operator=(const SrpClientKeyExchange& from) {
    CopyFrom(from);
    return *this;
  }

  static const SrpClientKeyExchange& default_instance();

  static inline const SrpClientKeyExchange* internal_default_instance() {
    return reinterpret_cast<const SrpClientKeyExchange*>(
               &_SrpClientKeyExchange_default_instance_);
  }

  void Swap(SrpClientKeyExchange* other);

  // implements Message ----------------------------------------------

  inline SrpClientKeyExchange* New() const PROTOBUF_FINAL { return New(NULL); }

  SrpClientKeyExchange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SrpClientKeyExchange& from);
  void MergeFrom(const SrpClientKeyExchange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SrpClientKeyExchange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes A = 1;
  void clear_a();
  static const int kAFieldNumber = 1;
  const ::std::string& a() const;
  void set_a(const ::std::string& value);
  #if LANG_CXX11
  void set_a(::std::string&& value);
  #endif
  void set_a(const char* value);
  void set_a(const void* value, size_t size);
  ::std::string* mutable_a();
  ::std::string* release_a();
  void set_allocated_a(::std::string* a);

  // bytes iv = 2;
  void clear_iv();
  static const int kIvFieldNumber = 2;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  #if LANG_CXX11
  void set_iv(::std::string&& value);
  #endif
  void set_iv(const char* value);
  void set_iv(const void* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // @@protoc_insertion_point(class_scope:proto.SrpClientKeyExchange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr a_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionChallenge : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionChallenge) */ {
 public:
  SessionChallenge();
  virtual ~SessionChallenge();

  SessionChallenge(const SessionChallenge& from);

  inline SessionChallenge& operator=(const SessionChallenge& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionChallenge& default_instance();

  static inline const SessionChallenge* internal_default_instance() {
    return reinterpret_cast<const SessionChallenge*>(
               &_SessionChallenge_default_instance_);
  }

  void Swap(SessionChallenge* other);

  // implements Message ----------------------------------------------

  inline SessionChallenge* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionChallenge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionChallenge& from);
  void MergeFrom(const SessionChallenge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionChallenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string os_name = 4;
  void clear_os_name();
  static const int kOsNameFieldNumber = 4;
  const ::std::string& os_name() const;
  void set_os_name(const ::std::string& value);
  #if LANG_CXX11
  void set_os_name(::std::string&& value);
  #endif
  void set_os_name(const char* value);
  void set_os_name(const char* value, size_t size);
  ::std::string* mutable_os_name();
  ::std::string* release_os_name();
  void set_allocated_os_name(::std::string* os_name);

  // string computer_name = 5;
  void clear_computer_name();
  static const int kComputerNameFieldNumber = 5;
  const ::std::string& computer_name() const;
  void set_computer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_computer_name(::std::string&& value);
  #endif
  void set_computer_name(const char* value);
  void set_computer_name(const char* value, size_t size);
  ::std::string* mutable_computer_name();
  ::std::string* release_computer_name();
  void set_allocated_computer_name(::std::string* computer_name);

  // .proto.Version version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::proto::Version& version() const;
  ::proto::Version* mutable_version();
  ::proto::Version* release_version();
  void set_allocated_version(::proto::Version* version);

  // uint32 session_types = 2;
  void clear_session_types();
  static const int kSessionTypesFieldNumber = 2;
  ::google::protobuf::uint32 session_types() const;
  void set_session_types(::google::protobuf::uint32 value);

  // uint32 cpu_cores = 3;
  void clear_cpu_cores();
  static const int kCpuCoresFieldNumber = 3;
  ::google::protobuf::uint32 cpu_cores() const;
  void set_cpu_cores(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.SessionChallenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr os_name_;
  ::google::protobuf::internal::ArenaStringPtr computer_name_;
  ::proto::Version* version_;
  ::google::protobuf::uint32 session_types_;
  ::google::protobuf::uint32 cpu_cores_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:proto.SessionResponse) */ {
 public:
  SessionResponse();
  virtual ~SessionResponse();

  SessionResponse(const SessionResponse& from);

  inline SessionResponse& operator=(const SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const SessionResponse& default_instance();

  static inline const SessionResponse* internal_default_instance() {
    return reinterpret_cast<const SessionResponse*>(
               &_SessionResponse_default_instance_);
  }

  void Swap(SessionResponse* other);

  // implements Message ----------------------------------------------

  inline SessionResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  SessionResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SessionResponse& from);
  void MergeFrom(const SessionResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string os_name = 4;
  void clear_os_name();
  static const int kOsNameFieldNumber = 4;
  const ::std::string& os_name() const;
  void set_os_name(const ::std::string& value);
  #if LANG_CXX11
  void set_os_name(::std::string&& value);
  #endif
  void set_os_name(const char* value);
  void set_os_name(const char* value, size_t size);
  ::std::string* mutable_os_name();
  ::std::string* release_os_name();
  void set_allocated_os_name(::std::string* os_name);

  // string computer_name = 5;
  void clear_computer_name();
  static const int kComputerNameFieldNumber = 5;
  const ::std::string& computer_name() const;
  void set_computer_name(const ::std::string& value);
  #if LANG_CXX11
  void set_computer_name(::std::string&& value);
  #endif
  void set_computer_name(const char* value);
  void set_computer_name(const char* value, size_t size);
  ::std::string* mutable_computer_name();
  ::std::string* release_computer_name();
  void set_allocated_computer_name(::std::string* computer_name);

  // .proto.Version version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::proto::Version& version() const;
  ::proto::Version* mutable_version();
  ::proto::Version* release_version();
  void set_allocated_version(::proto::Version* version);

  // uint32 session_type = 2;
  void clear_session_type();
  static const int kSessionTypeFieldNumber = 2;
  ::google::protobuf::uint32 session_type() const;
  void set_session_type(::google::protobuf::uint32 value);

  // uint32 cpu_cores = 3;
  void clear_cpu_cores();
  static const int kCpuCoresFieldNumber = 3;
  ::google::protobuf::uint32 cpu_cores() const;
  void set_cpu_cores(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:proto.SessionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr os_name_;
  ::google::protobuf::internal::ArenaStringPtr computer_name_;
  ::proto::Version* version_;
  ::google::protobuf::uint32 session_type_;
  ::google::protobuf::uint32 cpu_cores_;
  mutable int _cached_size_;
  friend struct  protobuf_key_5fexchange_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ClientHello

// uint32 encryption = 1;
inline void ClientHello::clear_encryption() {
  encryption_ = 0u;
}
inline ::google::protobuf::uint32 ClientHello::encryption() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.encryption)
  return encryption_;
}
inline void ClientHello::set_encryption(::google::protobuf::uint32 value) {
  
  encryption_ = value;
  // @@protoc_insertion_point(field_set:proto.ClientHello.encryption)
}

// .proto.Identify identify = 2;
inline void ClientHello::clear_identify() {
  identify_ = 0;
}
inline ::proto::Identify ClientHello::identify() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.identify)
  return static_cast< ::proto::Identify >(identify_);
}
inline void ClientHello::set_identify(::proto::Identify value) {
  
  identify_ = value;
  // @@protoc_insertion_point(field_set:proto.ClientHello.identify)
}

// bytes public_key = 3;
inline void ClientHello::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientHello::public_key() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.public_key)
  return public_key_.GetNoArena();
}
inline void ClientHello::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ClientHello.public_key)
}
#if LANG_CXX11
inline void ClientHello::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ClientHello.public_key)
}
#endif
inline void ClientHello::set_public_key(const char* value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ClientHello.public_key)
}
inline void ClientHello::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ClientHello.public_key)
}
inline ::std::string* ClientHello::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:proto.ClientHello.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientHello::release_public_key() {
  // @@protoc_insertion_point(field_release:proto.ClientHello.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientHello::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.public_key)
}

// bytes iv = 4;
inline void ClientHello::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientHello::iv() const {
  // @@protoc_insertion_point(field_get:proto.ClientHello.iv)
  return iv_.GetNoArena();
}
inline void ClientHello::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ClientHello.iv)
}
#if LANG_CXX11
inline void ClientHello::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ClientHello.iv)
}
#endif
inline void ClientHello::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ClientHello.iv)
}
inline void ClientHello::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ClientHello.iv)
}
inline ::std::string* ClientHello::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.ClientHello.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientHello::release_iv() {
  // @@protoc_insertion_point(field_release:proto.ClientHello.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientHello::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.ClientHello.iv)
}

// -------------------------------------------------------------------

// ServerHello

// .proto.Encryption encryption = 1;
inline void ServerHello::clear_encryption() {
  encryption_ = 0;
}
inline ::proto::Encryption ServerHello::encryption() const {
  // @@protoc_insertion_point(field_get:proto.ServerHello.encryption)
  return static_cast< ::proto::Encryption >(encryption_);
}
inline void ServerHello::set_encryption(::proto::Encryption value) {
  
  encryption_ = value;
  // @@protoc_insertion_point(field_set:proto.ServerHello.encryption)
}

// bytes iv = 2;
inline void ServerHello::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerHello::iv() const {
  // @@protoc_insertion_point(field_get:proto.ServerHello.iv)
  return iv_.GetNoArena();
}
inline void ServerHello::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.ServerHello.iv)
}
#if LANG_CXX11
inline void ServerHello::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.ServerHello.iv)
}
#endif
inline void ServerHello::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.ServerHello.iv)
}
inline void ServerHello::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.ServerHello.iv)
}
inline ::std::string* ServerHello::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.ServerHello.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerHello::release_iv() {
  // @@protoc_insertion_point(field_release:proto.ServerHello.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerHello::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.ServerHello.iv)
}

// -------------------------------------------------------------------

// SrpIdentify

// string username = 1;
inline void SrpIdentify::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpIdentify::username() const {
  // @@protoc_insertion_point(field_get:proto.SrpIdentify.username)
  return username_.GetNoArena();
}
inline void SrpIdentify::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpIdentify.username)
}
#if LANG_CXX11
inline void SrpIdentify::set_username(::std::string&& value) {
  
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpIdentify.username)
}
#endif
inline void SrpIdentify::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpIdentify.username)
}
inline void SrpIdentify::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpIdentify.username)
}
inline ::std::string* SrpIdentify::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpIdentify.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpIdentify::release_username() {
  // @@protoc_insertion_point(field_release:proto.SrpIdentify.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpIdentify::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpIdentify.username)
}

// -------------------------------------------------------------------

// SrpServerKeyExchange

// bytes number = 1;
inline void SrpServerKeyExchange::clear_number() {
  number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpServerKeyExchange::number() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.number)
  return number_.GetNoArena();
}
inline void SrpServerKeyExchange::set_number(const ::std::string& value) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.number)
}
#if LANG_CXX11
inline void SrpServerKeyExchange::set_number(::std::string&& value) {
  
  number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpServerKeyExchange.number)
}
#endif
inline void SrpServerKeyExchange::set_number(const char* value) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpServerKeyExchange.number)
}
inline void SrpServerKeyExchange::set_number(const void* value, size_t size) {
  
  number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpServerKeyExchange.number)
}
inline ::std::string* SrpServerKeyExchange::mutable_number() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.number)
  return number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpServerKeyExchange::release_number() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.number)
  
  return number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpServerKeyExchange::set_allocated_number(::std::string* number) {
  if (number != NULL) {
    
  } else {
    
  }
  number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), number);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.number)
}

// bytes generator = 2;
inline void SrpServerKeyExchange::clear_generator() {
  generator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpServerKeyExchange::generator() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.generator)
  return generator_.GetNoArena();
}
inline void SrpServerKeyExchange::set_generator(const ::std::string& value) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.generator)
}
#if LANG_CXX11
inline void SrpServerKeyExchange::set_generator(::std::string&& value) {
  
  generator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpServerKeyExchange.generator)
}
#endif
inline void SrpServerKeyExchange::set_generator(const char* value) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpServerKeyExchange.generator)
}
inline void SrpServerKeyExchange::set_generator(const void* value, size_t size) {
  
  generator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpServerKeyExchange.generator)
}
inline ::std::string* SrpServerKeyExchange::mutable_generator() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.generator)
  return generator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpServerKeyExchange::release_generator() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.generator)
  
  return generator_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpServerKeyExchange::set_allocated_generator(::std::string* generator) {
  if (generator != NULL) {
    
  } else {
    
  }
  generator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), generator);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.generator)
}

// bytes salt = 3;
inline void SrpServerKeyExchange::clear_salt() {
  salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpServerKeyExchange::salt() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.salt)
  return salt_.GetNoArena();
}
inline void SrpServerKeyExchange::set_salt(const ::std::string& value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.salt)
}
#if LANG_CXX11
inline void SrpServerKeyExchange::set_salt(::std::string&& value) {
  
  salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpServerKeyExchange.salt)
}
#endif
inline void SrpServerKeyExchange::set_salt(const char* value) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpServerKeyExchange.salt)
}
inline void SrpServerKeyExchange::set_salt(const void* value, size_t size) {
  
  salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpServerKeyExchange.salt)
}
inline ::std::string* SrpServerKeyExchange::mutable_salt() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.salt)
  return salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpServerKeyExchange::release_salt() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.salt)
  
  return salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpServerKeyExchange::set_allocated_salt(::std::string* salt) {
  if (salt != NULL) {
    
  } else {
    
  }
  salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), salt);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.salt)
}

// bytes B = 4;
inline void SrpServerKeyExchange::clear_b() {
  b_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpServerKeyExchange::b() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.B)
  return b_.GetNoArena();
}
inline void SrpServerKeyExchange::set_b(const ::std::string& value) {
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.B)
}
#if LANG_CXX11
inline void SrpServerKeyExchange::set_b(::std::string&& value) {
  
  b_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpServerKeyExchange.B)
}
#endif
inline void SrpServerKeyExchange::set_b(const char* value) {
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpServerKeyExchange.B)
}
inline void SrpServerKeyExchange::set_b(const void* value, size_t size) {
  
  b_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpServerKeyExchange.B)
}
inline ::std::string* SrpServerKeyExchange::mutable_b() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.B)
  return b_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpServerKeyExchange::release_b() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.B)
  
  return b_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpServerKeyExchange::set_allocated_b(::std::string* b) {
  if (b != NULL) {
    
  } else {
    
  }
  b_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), b);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.B)
}

// bytes iv = 5;
inline void SrpServerKeyExchange::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpServerKeyExchange::iv() const {
  // @@protoc_insertion_point(field_get:proto.SrpServerKeyExchange.iv)
  return iv_.GetNoArena();
}
inline void SrpServerKeyExchange::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpServerKeyExchange.iv)
}
#if LANG_CXX11
inline void SrpServerKeyExchange::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpServerKeyExchange.iv)
}
#endif
inline void SrpServerKeyExchange::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpServerKeyExchange.iv)
}
inline void SrpServerKeyExchange::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpServerKeyExchange.iv)
}
inline ::std::string* SrpServerKeyExchange::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpServerKeyExchange.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpServerKeyExchange::release_iv() {
  // @@protoc_insertion_point(field_release:proto.SrpServerKeyExchange.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpServerKeyExchange::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpServerKeyExchange.iv)
}

// -------------------------------------------------------------------

// SrpClientKeyExchange

// bytes A = 1;
inline void SrpClientKeyExchange::clear_a() {
  a_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpClientKeyExchange::a() const {
  // @@protoc_insertion_point(field_get:proto.SrpClientKeyExchange.A)
  return a_.GetNoArena();
}
inline void SrpClientKeyExchange::set_a(const ::std::string& value) {
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpClientKeyExchange.A)
}
#if LANG_CXX11
inline void SrpClientKeyExchange::set_a(::std::string&& value) {
  
  a_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpClientKeyExchange.A)
}
#endif
inline void SrpClientKeyExchange::set_a(const char* value) {
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpClientKeyExchange.A)
}
inline void SrpClientKeyExchange::set_a(const void* value, size_t size) {
  
  a_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpClientKeyExchange.A)
}
inline ::std::string* SrpClientKeyExchange::mutable_a() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpClientKeyExchange.A)
  return a_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpClientKeyExchange::release_a() {
  // @@protoc_insertion_point(field_release:proto.SrpClientKeyExchange.A)
  
  return a_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpClientKeyExchange::set_allocated_a(::std::string* a) {
  if (a != NULL) {
    
  } else {
    
  }
  a_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpClientKeyExchange.A)
}

// bytes iv = 2;
inline void SrpClientKeyExchange::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SrpClientKeyExchange::iv() const {
  // @@protoc_insertion_point(field_get:proto.SrpClientKeyExchange.iv)
  return iv_.GetNoArena();
}
inline void SrpClientKeyExchange::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SrpClientKeyExchange.iv)
}
#if LANG_CXX11
inline void SrpClientKeyExchange::set_iv(::std::string&& value) {
  
  iv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SrpClientKeyExchange.iv)
}
#endif
inline void SrpClientKeyExchange::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SrpClientKeyExchange.iv)
}
inline void SrpClientKeyExchange::set_iv(const void* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SrpClientKeyExchange.iv)
}
inline ::std::string* SrpClientKeyExchange::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:proto.SrpClientKeyExchange.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SrpClientKeyExchange::release_iv() {
  // @@protoc_insertion_point(field_release:proto.SrpClientKeyExchange.iv)
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SrpClientKeyExchange::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:proto.SrpClientKeyExchange.iv)
}

// -------------------------------------------------------------------

// SessionChallenge

// .proto.Version version = 1;
inline bool SessionChallenge::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void SessionChallenge::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) delete version_;
  version_ = NULL;
}
inline const ::proto::Version& SessionChallenge::version() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.version)
  return version_ != NULL ? *version_
                         : *::proto::Version::internal_default_instance();
}
inline ::proto::Version* SessionChallenge::mutable_version() {
  
  if (version_ == NULL) {
    version_ = new ::proto::Version;
  }
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.version)
  return version_;
}
inline ::proto::Version* SessionChallenge::release_version() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.version)
  
  ::proto::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void SessionChallenge::set_allocated_version(::proto::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.version)
}

// uint32 session_types = 2;
inline void SessionChallenge::clear_session_types() {
  session_types_ = 0u;
}
inline ::google::protobuf::uint32 SessionChallenge::session_types() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.session_types)
  return session_types_;
}
inline void SessionChallenge::set_session_types(::google::protobuf::uint32 value) {
  
  session_types_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.session_types)
}

// uint32 cpu_cores = 3;
inline void SessionChallenge::clear_cpu_cores() {
  cpu_cores_ = 0u;
}
inline ::google::protobuf::uint32 SessionChallenge::cpu_cores() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.cpu_cores)
  return cpu_cores_;
}
inline void SessionChallenge::set_cpu_cores(::google::protobuf::uint32 value) {
  
  cpu_cores_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.cpu_cores)
}

// string os_name = 4;
inline void SessionChallenge::clear_os_name() {
  os_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionChallenge::os_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.os_name)
  return os_name_.GetNoArena();
}
inline void SessionChallenge::set_os_name(const ::std::string& value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.os_name)
}
#if LANG_CXX11
inline void SessionChallenge::set_os_name(::std::string&& value) {
  
  os_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SessionChallenge.os_name)
}
#endif
inline void SessionChallenge::set_os_name(const char* value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SessionChallenge.os_name)
}
inline void SessionChallenge::set_os_name(const char* value, size_t size) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SessionChallenge.os_name)
}
inline ::std::string* SessionChallenge::mutable_os_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.os_name)
  return os_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionChallenge::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.os_name)
  
  return os_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionChallenge::set_allocated_os_name(::std::string* os_name) {
  if (os_name != NULL) {
    
  } else {
    
  }
  os_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_name);
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.os_name)
}

// string computer_name = 5;
inline void SessionChallenge::clear_computer_name() {
  computer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionChallenge::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionChallenge.computer_name)
  return computer_name_.GetNoArena();
}
inline void SessionChallenge::set_computer_name(const ::std::string& value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SessionChallenge.computer_name)
}
#if LANG_CXX11
inline void SessionChallenge::set_computer_name(::std::string&& value) {
  
  computer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SessionChallenge.computer_name)
}
#endif
inline void SessionChallenge::set_computer_name(const char* value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SessionChallenge.computer_name)
}
inline void SessionChallenge::set_computer_name(const char* value, size_t size) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SessionChallenge.computer_name)
}
inline ::std::string* SessionChallenge::mutable_computer_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.SessionChallenge.computer_name)
  return computer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionChallenge::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.SessionChallenge.computer_name)
  
  return computer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionChallenge::set_allocated_computer_name(::std::string* computer_name) {
  if (computer_name != NULL) {
    
  } else {
    
  }
  computer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), computer_name);
  // @@protoc_insertion_point(field_set_allocated:proto.SessionChallenge.computer_name)
}

// -------------------------------------------------------------------

// SessionResponse

// .proto.Version version = 1;
inline bool SessionResponse::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void SessionResponse::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) delete version_;
  version_ = NULL;
}
inline const ::proto::Version& SessionResponse::version() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.version)
  return version_ != NULL ? *version_
                         : *::proto::Version::internal_default_instance();
}
inline ::proto::Version* SessionResponse::mutable_version() {
  
  if (version_ == NULL) {
    version_ = new ::proto::Version;
  }
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.version)
  return version_;
}
inline ::proto::Version* SessionResponse::release_version() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.version)
  
  ::proto::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void SessionResponse::set_allocated_version(::proto::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.version)
}

// uint32 session_type = 2;
inline void SessionResponse::clear_session_type() {
  session_type_ = 0u;
}
inline ::google::protobuf::uint32 SessionResponse::session_type() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.session_type)
  return session_type_;
}
inline void SessionResponse::set_session_type(::google::protobuf::uint32 value) {
  
  session_type_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionResponse.session_type)
}

// uint32 cpu_cores = 3;
inline void SessionResponse::clear_cpu_cores() {
  cpu_cores_ = 0u;
}
inline ::google::protobuf::uint32 SessionResponse::cpu_cores() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.cpu_cores)
  return cpu_cores_;
}
inline void SessionResponse::set_cpu_cores(::google::protobuf::uint32 value) {
  
  cpu_cores_ = value;
  // @@protoc_insertion_point(field_set:proto.SessionResponse.cpu_cores)
}

// string os_name = 4;
inline void SessionResponse::clear_os_name() {
  os_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionResponse::os_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.os_name)
  return os_name_.GetNoArena();
}
inline void SessionResponse::set_os_name(const ::std::string& value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SessionResponse.os_name)
}
#if LANG_CXX11
inline void SessionResponse::set_os_name(::std::string&& value) {
  
  os_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SessionResponse.os_name)
}
#endif
inline void SessionResponse::set_os_name(const char* value) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SessionResponse.os_name)
}
inline void SessionResponse::set_os_name(const char* value, size_t size) {
  
  os_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SessionResponse.os_name)
}
inline ::std::string* SessionResponse::mutable_os_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.os_name)
  return os_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionResponse::release_os_name() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.os_name)
  
  return os_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionResponse::set_allocated_os_name(::std::string* os_name) {
  if (os_name != NULL) {
    
  } else {
    
  }
  os_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_name);
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.os_name)
}

// string computer_name = 5;
inline void SessionResponse::clear_computer_name() {
  computer_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionResponse::computer_name() const {
  // @@protoc_insertion_point(field_get:proto.SessionResponse.computer_name)
  return computer_name_.GetNoArena();
}
inline void SessionResponse::set_computer_name(const ::std::string& value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:proto.SessionResponse.computer_name)
}
#if LANG_CXX11
inline void SessionResponse::set_computer_name(::std::string&& value) {
  
  computer_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:proto.SessionResponse.computer_name)
}
#endif
inline void SessionResponse::set_computer_name(const char* value) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:proto.SessionResponse.computer_name)
}
inline void SessionResponse::set_computer_name(const char* value, size_t size) {
  
  computer_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:proto.SessionResponse.computer_name)
}
inline ::std::string* SessionResponse::mutable_computer_name() {
  
  // @@protoc_insertion_point(field_mutable:proto.SessionResponse.computer_name)
  return computer_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionResponse::release_computer_name() {
  // @@protoc_insertion_point(field_release:proto.SessionResponse.computer_name)
  
  return computer_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionResponse::set_allocated_computer_name(::std::string* computer_name) {
  if (computer_name != NULL) {
    
  } else {
    
  }
  computer_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), computer_name);
  // @@protoc_insertion_point(field_set_allocated:proto.SessionResponse.computer_name)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::proto::Identify> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::proto::Encryption> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_key_5fexchange_2eproto__INCLUDED
